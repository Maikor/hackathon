{
  
  
  
  
    "wkinstructions-2019-02-01-step-1-understanding-ztp-libraries-on-ios-xr": {
      "title": "Step 1: Understanding ZTP Libraries on IOS-XR",
      "content": "     On This Page  Introduction# Understanding ZTP and the ZTP bash and Python helper libraries          The ZTP Helper Libraries                  ZTP Helper bash Libary          ZTP Helper Python Libary                          ZtpHelpers class Methods#                                            .Introduction# Understanding ZTP and the ZTP bash and Python helper librariesZero Touch Provisioning(ZTP) is a device provisioning mechanism that allows network devices running IOS-XR to be powered-on and provisioned in a completely automated fashion. The high-level workflow for ZTP is as follows#  The network-device with an IOS-XR image installed is powered on.  Upon boot-up, the ZTP process runs if the device does not have a prior configuration.  The ZTP process triggers dhclient on the Management port (and with the upcoming IOS-XR 6.5.1 release, even on the production/data ports) to send out a DHCP request identifying itself using DHCP options#          DHCP(v4/v6) client-id=Serial Number,      DHCPv4 option 124# Vendor, Platform, Serial-Number      DHCPv6 option 16# Vendor, Platform, Serial-Number        The DHCP server identifies the device and responds with either an IOS-XR configuration file or a ZTP script as the filename option.  If the device receives a configuration file, it would simply apply the configuration and terminate the ZTP process.  If the device receives a script or binary executable, it will simply execute the script/binary in the default bash shell in a network namespace corresponding to the global/default VRF. This script can be used to configure the device and/or install IOS-XR packages, set up linux applications etc.This workflow is depicted in the figure below#  The concepts behind IOS-XR ZTP and further details on its operationalization in your network are expanded upon in the great set of blogs and tutorials on https#//xrdocs.io. In particular#      Working with IOS-XR ZTP    IOS-XR ZTP# Learning through Packet Captures  The ZTP Helper LibrariesIt is clear from the above workflow that the DHCP server can respond to the device with a script/binary as one of the options.This script/binary is executed in the IOS-XR Bash shell and may be used to interact with IOS-XR CLI to configure, verify the configured state and even run exec commands based on the workflow that the operator chooses.So it goes without saying that the IOS-XR Bash shell must offer utilties/APIs/hooks that can allow a downloaded script/binary to interact-with/automate the IOS-XR CLI.These utilities are provided by the ZTP helper libraries for Bash and Python that are available for scripts running on-box in the IOS-XR Linux shell.ZTP Helper bash LibaryThe ZTP helper bash library is simply a bash script that creates useful wrappers out of pre-existing IOS-XR CLI interaction binaries in the IOS-XR shell.On the router, this helper script is located at /pkg/bin/ztp_helper.sh.To use this library, any Bash script (or even python scripts utilizing bash calls) must import the ztp_helper.sh library.  Upon import, the following bash hooks become available#            Bash Utility      Argument      Function                  xrcmd      &lt;exec or show command&gt;      Exec commands and show commands in XR CLI              xrapply      &lt;local filename&gt;       Configuration Merge.Apply additional configuration using a file              xrapply_with_reason      Arg1# &lt;reason&gt; Arg2# &lt;local filename&gt;&lt;img width=180/&gt;       Configuration Merge Apply additional configuration using a file along with a reason   P.S. reason shows up as comment in show configuration commit list detail              xrapply_string      &lt;config string&gt;      Configuration Merge. Apply additional configuration using a single line string (carriage returns are affected using \\n)              xrapply_string_with_reason      Arg1# &lt;reason&gt;Arg2#&lt;config string&gt;      Configuration Merge.Apply additional configuration using a single line string (carriage returns are affected using \\n)  P.S. reason shows up as comment in show configuration commit list detail              xrreplace      &lt;local filename&gt;      Configuration Replace.Replace existing configuration with the configuration contained in the filename specified as argument.      ZTP Helper Python LibaryThe ZTP helper Python library is simply a python script that creates useful wrappers out of pre-existing IOS-XR CLI interaction binaries in the IOS-XR shell.On the router, this helper script is located at /pkg/bin/ztp_helper.sh.To use this library, any Python script  must import the ztp_helper.py library.  Upon import, the following python hooks become available#The ZTP python library defines a single Python class called ZtpHelpers. This class contains all the utility methods that are described below.ZtpHelpers class Methods#Object Creation#  __init__()Purpose# This method is invoked when the ZtpHelpers object is created.All of the following parameters are optional. Python’s default syslog capability is utilized for the setting below. When nothing is specified during object creation, then all logs are sent to a log rotated file /tmp/ztp_python.log (max size of 1MB)Input Parameters  syslog_server# IP address of reachable Syslog Server          Parameter type# string        syslog_port# Port for the reachable syslog server          Parameter type# int        syslog_file# Alternative or add-on file to store syslog          Parameter type# string      Debug Logging#  toggle_debug()Purpose# Used to Enable/disable verbose debug loggingInput Parameters  enable# Enable/Disable flag          Parameter Type# int      Show/Exec CLI commands#    xrcmd()Purpose# Issue an IOS-XR show command or exec command and obtain the output.Input Parameters      cmd# Dictionary representing the XR exec cmd and response to potential promptsParameter Type# dictThese values are encoded in the dict as follows{ 'exec_cmd'# '', 'prompt_response'# '' }.    In the dictionary, prompt_response is an optional field meant for exec commands that require the script to answer prompts offered by the IOS-XR shell in response to exec_cmd.  Return ValueReturn Type# dictReturns a dictionary with status and output in the format#{ 'status'# 'error/success', 'output'# '' }Here status=error if an invalid exec/show command is specified as input to XR CLI and output is the actual show command output or exec command response in case of success.Configuration Merge using a File# xrapply()Purpose# Apply Configuration to XR using a local file on the router. This method does a configuration merge.Input Parameters  filename# Filepath for a local file containing valid IOS-XR CLI configuration          Parameter Type# string        reason# Reason for the configuration commit. Will show up in the output of# show configuration commit list &lt;&gt; detail. This parameter is optional.          Parameter Type# string      Return ValueReturn Type# dictDictionary specifying the effect of the config change#{ 'status' # 'error/success', 'output'# 'exec command based on status'}      Here status=error if the configuration merge was unsuccessful and the corresponding output is the response of the show command = show configuration failed.        Similarly, status=success if the configuration merge is successful and the corresponding output is the response of show configuration commit changes last 1  Configuration Merge using a String# xrapply_string()Purpose# Apply Configuration to XR using a string. This method does a configuration merge.Input Parameters  cmd# Single line or Multi-Line string that contains valid IOS-XR CLI configuration.      Parameter Type# string    reason# Reason for the configuration commit. Will show up in the output of# show configuration commit list &lt;&gt; detail.This parameter is optional.          Parameter Type# string      Return Value&lt;/bReturn Type# dictDictionary specifying the effect of the config change#{ 'status' # 'error/success', 'output'# 'exec command based on status'}      Here status=error if the configuration merge was unsuccessful and the corresponding output is the response of show configuration failed.        Similarly, status=success if the configuration merge is successful and the corresponding output is the response of show configuration commit changes last 1  Configuration Replace using a file# xrreplace()Purpose# Completely Replace existing Router configuration with the configuration specified in a file.Input Parameters  filename# Filepath for a local file containing valid IOS-XR CLI configuration          Parameter Type# string      Return ValueReturn Type# dictDictionary specifying the effect of the config change#{ 'status' # 'error/success', 'output'# 'exec command based on status'}      Here status=error if the configuration merge was unsuccessful and the corresponding output is the response of show configuration failed.        Similarly, status=success if the configuration merge is successful and the corresponding output is the response of show configuration commit changes last 1.  ",
      "url": "/wkinstructions/2019-02-01-step-1-understanding-ztp-libraries-on-ios-xr/",
      "author": "Akshat Sharma",
      "tags": "iosxr, cisco, ztp, cleur2019, lab"
    }
    
    ,
  
  
  
    "wkinstructions-2019-02-01-step-2-playing-with-the-onbox-ios-xr-ztp-bash-library": {
      "title": "Step 2: Playing with the onbox IOS-XR ZTP Bash and Python Library",
      "content": "     On This Page  Playing with the onbox ZTP bash hooks          Connect to router r1      Show commands                  Drop into Bash          Source the ztp_helper.sh library          Execute the show command          Checking an invalid show command          Running an exec command                          Dump the initial set of logs              Clear the logs using xrcmd                                Running admin commands                    Configuration Merge                  Using xrapply to bring up GigabitEthernet0/0/0/0                          Create the local configuration file              Source /pkg/bin/ztp_helper.sh              Do a configuration merge using xrapply              Check the return value              Verify the configuration was properly applied                                Using xrapply with an invalid Configuration file                          Create an invalid configuration file              Do a config merge using xrapply              Check the return code                                Using xrapply_string_with_reason to configure GigabitEthernet0/0/0/1                    Configuration Replace        Playing with the Onbox ZTP Python hooks          Connect to router r1      Show commands                  Execute the show command          Checking an invalid show command          Running an exec command                          Dump the initial set of logs              Clear the logs using xrcmd                                Running admin commands                    Configuration Merge                  Using xrapply() to bring up GigabitEthernet0/0/0/0                          Create the local configuration file              Import  ZtpHelpers from /pkg/bin/ztp_helper.py              Do a configuration merge using xrapply              Check the return value                                Using xrapply with an invalid Configuration file                          Create an invalid configuration file              Do a config merge using xrapply                                Using xrapply_string() with the reason parameter to configure GigabitEthernet0/0/0/1                    Configuration Replace        Playing with the onbox ZTP bash hooksTime to play around with the ZTP Bash hooks! Let’s try out a few use cases.We’ll choose router r1 as our test platform.  Connect to your Pod first! Make sure your Anyconnect VPN connection to the Pod assigned to you is active.  If you haven’t connected yet, check out the instructions to do so here#https#//iosxr-lab-ciscolive.github.io/LTRSPG-2414-cleur2019/assets/CLEUR19-AkshatSharma-IOS-XR-Programmability-Session-1-Friday.pdf  Once you’re connected, use the following instructions to connect to the individual nodes.The instructions in the workshop will simply refer to the Name of the box to connect withoutrepeating the connection details and credentials. So refer back to this list when you need it.  The 3 nodes in the topology are#  Development Linux System (DevBox)   IP Address# 10.10.20.170 Username/Password# [admin/admin] SSH Port# 2211    IOS-XRv9000 R1# (Router r1)  IP Address# 10.10.20.170  Username/Password# [admin/admin]   Management IP# 10.10.20.170  XR SSH Port# 2221    NETCONF Port# 8321   gRPC Port# 57021  XR-Bash SSH Port# 2222        IOS-XRv9000 R2#  (Router r2)  IP Address# 10.10.20.170   Username/Password# [admin/admin]   Management IP# 10.10.20.170   XR SSH Port# 2231    NETCONF Port# 8331   gRPC Port# 57031    XR-Bash SSH Port# 2232  The Topology in use is shown below#Connect to router r1Username# adminPassword# adminSSH port# 2221IP# 10.10.20.170Laptop-terminal#$ ssh -p 2221 admin@10.10.20.170--------------------------------------------------------------------------  Router 1 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#Show commandsThe xrcmd utility is used for this purpose. Let’s dump the running configuration.To use this utility drop into the IOS-XR bash shell using the bash CLI and first source the /pkg/bin/ztp_helper.sh library.Drop into BashRP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#bashSun Aug 19 21#43#45.615 UTC[r1#~]$[r1#~]$Source the ztp_helper.sh library[r1#~]$ source /pkg/bin/ztp_helper.sh[r1#~]$Execute the show command[r1#~]$ xrcmd ~show running-config~Building configuration...!! IOS XR Configuration version = 6.4.1!! Last configuration change at Sun Aug 19 21#44#14 2018 by ZTP!hostname r1banner motd ;--------------------------------------------------------------------------  Router 1 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------;service timestamps log datetime msecservice timestamps debug datetime msecusername admin group root-lr group cisco-support secret 5 $1$A4C9$oaNorr6BXDruE4gDd086L.!line console timestamp disable exec-timeout 0 0!vty-pool default 0 4 line-template VTY-TEMPLATEcall-home service active contact smart-licensing profile CiscoTAC-1  active  destination transport-method http !!interface MgmtEth0/RP0/CPU0/0 description *** MANAGEMENT INTERFACE *** ipv4 address dhcp!interface GigabitEthernet0/0/0/0 shutdown!interface GigabitEthernet0/0/0/1 shutdown!interface GigabitEthernet0/0/0/2 shutdown!interface GigabitEthernet0/0/0/3 shutdown!interface GigabitEthernet0/0/0/4 shutdown!router static address-family ipv4 unicast  0.0.0.0/0 192.168.122.1 !!netconf-yang agent ssh!ssh server v2ssh server netconf vrf defaultend[r1#~]$Checking an invalid show commandThe return value for xrcmd will unfortunately always be 0, so it is incumbent on us to parse the output and check for the string % Invalid input detected at '^' marker. which is dependable. The python library that the next learning lab in this module will showcase, already does this and returns a proper error code.[r1#~]$[r1#~]$ xrcmd ~Hello World~showtech_helper error# Parsing of command ~Hello World~ failedHello World ^% Invalid input detected at '^' marker.[r1#~]$Running an exec commandExec commands are essentially run in the exec mode and they can affect the state of the system unlike show commands that are read-only actions.For example, let’s say we want to clear the logs on the system. We can utilize xrcmd to do so. But in addition, exec commands usually offer prompts that must be handled as part of the xrcmd call. We do so by taking advantage of some bash capabilities as shown below#Dump the initial set of logsYour logs at this stage could look completely different but dump the last 10 lines of the current logs to verify that the clearing process works#[r1#~]$ xrcmd ~show logging~ |  tail -10RP/0/RP0/CPU0#Aug 20 01#39#10.662 UTC# devc-vty[298]# The specified TTY (4, 8) is not registered in the DBRP/0/RP0/CPU0#Aug 20 01#39#10.704 UTC# devc-vty[298]# The specified TTY (4, 8) is not registered in the DBRP/0/RP0/CPU0#Aug 20 01#39#23.505 UTC# nvgen[65561]# %MGBL-CONFIG_HIST_UPDATE-3-SYSDB_GET # Error 'sysdb' detected the 'warning' condition 'A verifier or EDM callback function returned# 'not found'' getting host address from  sysdbRP/0/RP0/CPU0#Aug 20 01#39#23.660 UTC# devc-vty[298]# The specified TTY (4, 8) is not registered in the DBRP/0/RP0/CPU0#Aug 20 01#39#23.676 UTC# devc-vty[298]# The specified TTY (4, 8) is not registered in the DBRP/0/RP0/CPU0#Aug 20 01#39#23.703 UTC# devc-vty[298]# The specified TTY (4, 8) is not registered in the DBRP/0/RP0/CPU0#Aug 20 01#49#21.506 UTC# SSHD_[68896]# %SECURITY-SSHD-6-INFO_USER_LOGOUT # User 'admin' from '192.168.122.1' logged out on 'vty0'RP/0/RP0/CPU0#Aug 20 01#57#56.782 UTC# SSHD_[66208]# %SECURITY-SSHD-6-INFO_SUCCESS # Successfully authenticated user 'admin' from '192.168.122.1' on 'vty0'(cipher 'aes128-ctr', mac 'hmac-sha2-256')RP/0/RP0/CPU0#Aug 20 02#08#17.238 UTC# SSHD_[66208]# %SECURITY-SSHD-6-INFO_USER_LOGOUT # User 'admin' from '192.168.122.1' logged out on 'vty0'RP/0/RP0/CPU0#Aug 20 02#13#26.371 UTC# SSHD_[66446]# %SECURITY-SSHD-6-INFO_SUCCESS # Successfully authenticated user 'admin' from '192.168.122.1' on 'vty0'(cipher 'aes128-ctr', mac 'hmac-sha2-256')[r1#~]$Clear the logs using xrcmdclear logging as an exec command prompts the user like so#RP/0/RP0/CPU0#r1#clear loggingMon Aug 20 01#58#14.572 UTCClear logging buffer [confirm] [y/n] #So to automate against this, simply echo out “y” in response to the xrcmd output. To do that, we can use#[r1#~]$[r1#~]$[r1#~]$ echo -ne ~y\\n~ | xrcmd ~clear logging~Clear logging buffer [confirm] [y/n] #[r1#~]$[r1#~]$Great! Now checking the output of “show logging” again#[r1#~]$ xrcmd ~show logging~Syslog logging# enabled (0 messages dropped, 0 flushes, 0 overruns)    Console logging# level warnings, 39 messages logged    Monitor logging# level debugging, 0 messages logged    Trap logging# level informational, 0 messages logged    Buffer logging# level debugging, 0 messages loggedLog Buffer (2097152 bytes)#[r1#~]$[r1#~]$Running admin commandsIn IOS-XR the admin mode is a privileged mode that allows you to run certain administrative exec commands like reloading or shutting down the box, running privileged show commands like “admin show environment power” etc.To run these commands we again utilize xrcmd and the power of echo to funnel in the required admin show/exec commands to the admin mode.Since we’re on a virtual router, we can’t really get environment dumps, so let’s issue a simple “show platform” on the admin cli.Running admin commands require a root-lr user to be configured on the router and an environment variable AAA_USER is used along with ZTP bash hooks to enable privilege associated with the root-lr user to gain access to the admin mode. Since the router has `admin` configured as the root-lr user, we set `AAA_USER=admin`[r1#~]$[r1#~]$ export AAA_USER=admin &amp;&amp; echo -ne ~show platform\\n~ | xrcmd ~admin~ztp-user connected from 127.0.0.1 using console on r1sysadmin-vm#0_RP0# show platformMon Aug  20 02#29#28.260 UTCLocation  Card Type               HW State      SW State      Config State  ----------------------------------------------------------------------------0/0       R-IOSXRV9000-LC-C       OPERATIONAL   N/A           NSHUT         0/RP0     R-IOSXRV9000-RP-C       OPERATIONAL   OPERATIONAL   NSHUT         sysadmin-vm#0_RP0# [r1#~]$Perfect! Any admin command you would potentially want to perform (even configuration in the admin shell) can be performed using the above method - reloads, reload to ipxe, change the state of the LEDs on the box, etc. Just use a combination of `\\n` to separate out individual lines meant for the admin CLI. We can now proceed with the configuration manipulation hooks.Configuration MergeEarlier, we listed 4 different utilities that allow you to play around with configuration merge on IOS-XR#xrapplyxrapply_with_reasonxrapply_stringxrapply_string_with_reasonWe will just try xrapply and xrapply_string_with_reason as a quick showcase. It is an exercise for the reader to try out the other utilities outside the context of this lab. We’ve already seen the existing configuration, so let’s use the config merge utilities one by one to bring up GigabitEthernet Interfaces on r1.Important# We expect the user to perform the same exact steps on r2 before we head to the next section! Remember interfaces on both the routers should be up before we try to bring up protocols on the box using a bash script we will develop in the next sectionUsing xrapply to bring up GigabitEthernet0/0/0/0xrapply uses a configuration file as an argument.So let’s create a file in the IOS-XR shell with the following content#Create the local configuration file[r1#~]$ cat &gt; /root/gig0up.conf &lt;&lt; EOF&gt; !&gt; interface GigabitEthernet0/0/0/0&gt;   ipv4 address 10.1.1.10/24&gt;   no shutdown&gt; !&gt; end&gt; EOF[r1#~]$You could use vi for this purpose as well. In the end the file looks something like#[r1#~]$ cat /root/gig0up.conf!interface GigabitEthernet0/0/0/0  ipv4 address 10.1.1.10/24  no shutdown!end[r1#~]$Now xrapply will add this configuration to the pre-existing configuration and will bring up GigabitEthernet0/0/0/0 with the ip address 10.1.1.10/24.Source /pkg/bin/ztp_helper.shYou might not need to source it if you're working in the same shell as the xrcmd command earlier.[r1#~]$[r1#~]$ source /pkg/bin/ztp_helper.sh[r1#~]$Do a configuration merge using xrapply[r1#~]$ xrapply /root/gig0up.conf[r1#~]$Check the return value[r1#~]$ echo $?0[r1#~]$exit code 0 indicates that the configuration application was successful!Verify the configuration was properly appliedWe’ll use the xrcmd utility to verify (exactly as you would in your own script)#[r1#~]$[r1#~]$ xrcmd ~show configuration commit changes last 1~Building configuration...!! IOS XR Configuration version = 6.4.1interface GigabitEthernet0/0/0/0 ipv4 address 10.1.1.10 255.255.255.0!end[r1#~]$Also, verify that the interface is up as expected#[r1#~]$ xrcmd ~show ip int br~Interface                      IP-Address      Status          Protocol Vrf-NameMgmtEth0/RP0/CPU0/0            192.168.122.21  Up              Up       defaultGigabitEthernet0/0/0/0         10.1.1.10       Up              Up       defaultGigabitEthernet0/0/0/1         unassigned      Shutdown        Down     defaultGigabitEthernet0/0/0/2         unassigned      Shutdown        Down     defaultGigabitEthernet0/0/0/3         unassigned      Shutdown        Down     defaultGigabitEthernet0/0/0/4         unassigned      Shutdown        Down     default[r1#~]$[r1#~]$Using xrapply with an invalid Configuration fileJust for kicks, let’s see what happens if we create an invalid configuration file and try to use xrapply#Create an invalid configuration file[r1#~]$[r1#~]$ cat &gt; /root/invalid_config_file &lt;&lt; EOF&gt; !&gt; interface invalid-interface-name&gt;   ipv4 address 1.1.1.2/24&gt;   no shutdown&gt; !&gt; end&gt; EOF[r1#~]$Do a config merge using xrapply[r1#~]$[r1#~]$ xrapply /root/invalid_config_file!! SYNTAX/AUTHORIZATION ERRORS# This configuration failed due to!! one or more of the following reasons#!!  - the entered commands do not exist,!!  - the entered commands have errors in their syntax,!!  - the software packages containing the commands are not active,!!  - the current user is not a member of a task-group that has!!    permissions to use the commands.interface invalid-interface-name  ipv4 address 1.1.1.2/24  no shutdown[r1#~]$Great! it throws up an error!Check the return code[r1#~]$[r1#~]$ echo $?1[r1#~]$This is very useful# by throwing up a distinct non-zero exit code upon failure to apply the configuration, it allows us to automate more deterministically.Using xrapply_string_with_reason to configure GigabitEthernet0/0/0/1The steps are illustrated below, think of it as a combination of the requirements for xrapply_string and xrapply_with_reason.[r1#~]$[r1#~]$ read -r -d '' gigup1_config &lt;&lt; EOF&gt; !&gt; interface GigabitEthernet0/0/0/1&gt;   ipv4 address 11.1.1.10/24&gt;   no shutdown&gt; !&gt; end&gt; EOF[r1#~]$[r1#~]$ echo ~$gigup1_config~!interface GigabitEthernet0/0/0/3  ipv4 address 11.1.1.10/24  no shutdown!end[r1#~]$[r1#~]$ xrapply_string_with_reason ~Testing xrapply_string_with_reason~ ~$gigup1_config~[r1#~]$[r1#~]$[r1#~]$ xrcmd ~show configuration commit list 1 detail~   1) CommitId# 1000000024                 Label# NONE      UserId#   ZTP                        Line#  ZTP      Client#   CLI                        Time#  Mon Aug 20 00#47#24 2018      Comment#  Testing xrapply_string_with_reason[r1#~]$[r1#~]$[r1#~]$ xrcmd ~show configuration commit changes last 1 ~Building configuration...!! IOS XR Configuration version = 6.4.1interface GigabitEthernet0/0/0/1 ipv4 address 11.1.1.10 255.255.255.0 no shutdown!end[r1#~]$[r1#~]$ xrcmd ~show ipv4 interface brief~Interface                      IP-Address      Status          Protocol Vrf-NameMgmtEth0/RP0/CPU0/0            192.168.122.21  Up              Up       defaultGigabitEthernet0/0/0/0         10.1.1.10       Up              Up       defaultGigabitEthernet0/0/0/1         11.1.1.10       Up              Up       defaultGigabitEthernet0/0/0/2         unassigned      Shutdown        Down     defaultGigabitEthernet0/0/0/3         unassigned      Shutdown        Down     defaultGigabitEthernet0/0/0/4         unassigned      Shutdown        Down     default[r1#~]$[r1#~]$Configuration ReplaceVery Very Important# Configuration Replace can be potentially dangerous. If you make a mistake with the type of configuration you want to enforce, you can potentially lose connectivity to the router. So make sure you take precautions to ensure the final config is what you want at the end of the processWe will not be attempting an xrreplace as part of this lab. But The basic workflow for using xrreplace is the same as xrapply. Provide a file containing the config to xrreplace and upon execution it will replace the entire configuration on the router with the configuration specified in the file.Playing with the Onbox ZTP Python hooksTime to play around with the ZTP Python hooks! Let’s try out a few use cases.We’ll choose router r1 as our test platform.Follow instructions in the “Before you Begin” section to understand the SSH ports you have access to.Connect to router r1Username# adminPassword# adminSSH port# 2221IP# 10.10.20.170Laptop-terminal#$ ssh -p 2221 admin@10.10.20.170--------------------------------------------------------------------------  Router 1 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#Show commandsThe xrcmd() utility is used for this purpose. Let’s dump the running configuration.To use this utility drop into the IOS-XR bash shell using the bash CLI and open up the python interpreter#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#bash  Sat Sep  8 18#53#22.730 UTC[r1#~]$[r1#~]$ pythonPython 2.7.3 (default, Dec 12 2017, 08#22#03)[GCC 4.9.1] on linux2Type ~help~, ~copyright~, ~credits~ or ~license~ for more information.&gt;&gt;&gt;Now let’s import the ZtpHelpers class from the  /pkg/bin/ztp_helper.py module. Multiple ways to do this, but we simply append the sys.path to include /pkg/bin.Further, to use the utilities provided by the ZtpHelpers class we need to create an object of this class#&gt;&gt;&gt;&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(~/pkg/bin~)&gt;&gt;&gt; from ztp_helper import ZtpHelpers&gt;&gt;&gt;&gt;&gt;&gt; ztp_obj=ZtpHelpers()&gt;&gt;&gt;Execute the show commandThe xrcmd method in the ZtpHelpers class allows us to run show and exec commands in XR CLI. It takes a cmd parameter as input which is a dictionary of the structure#{ 'exec_cmd'# '', 'prompt_response'# '' }prompt_response is an optional field meant for exec commands that require the script to answer prompts offered by the IOS-XR shell in response to exec_cmd.Let’s try and fetch the running-config from the router. We’re still in the python interpreter on the router#&gt;&gt;&gt; cmd={~exec_cmd~ # ~show running-config~}&gt;&gt;&gt; ztp_obj.xrcmd(cmd)Building configuration...{'status'# 'success', 'output'# ['!! IOS XR Configuration version = 6.4.1', '!! Last configuration change at Sat Sep  8 19#07#36 2018 by ZTP', '!', 'hostname r1', 'banner motd ;', '--------------------------------------------------------------------------', 'Router 1 (Cisco IOS XR Sandbox)', '--------------------------------------------------------------------------', ';', 'logging console debugging', 'service timestamps log datetime msec', 'service timestamps debug datetime msec', 'username admin', 'group root-lr', 'group cisco-support', 'secret 5 $1$A4C9$oaNorr6BXDruE4gDd086L.', '!', 'line console', 'timestamp disable', 'exec-timeout 0 0', '!', 'vty-pool default 0 4 line-template VTY-TEMPLATE', 'call-home', 'service active', 'contact smart-licensing', 'profile CiscoTAC-1', 'active', 'destination transport-method http', '!', '!', 'interface MgmtEth0/RP0/CPU0/0', 'description *** MANAGEMENT INTERFACE ***', 'ipv4 address dhcp', '!', 'interface GigabitEthernet0/0/0/0', 'ipv6 address 1010#1010##10/64', 'ipv6 enable', '!', 'interface GigabitEthernet0/0/0/1', 'ipv6 address 2020#2020##10/64', 'ipv6 enable', '!', 'interface GigabitEthernet0/0/0/2', 'shutdown', '!', 'interface GigabitEthernet0/0/0/3', 'shutdown', '!', 'interface GigabitEthernet0/0/0/4', 'shutdown', '!', 'router static', 'address-family ipv4 unicast', '0.0.0.0/0 10.0.2.2', '1.2.3.5/32 10.0.2.2', '!', '!', 'router bgp 65400', 'bgp router-id 11.1.1.10', 'address-family ipv4 unicast', 'network 11.1.1.0/24', '!', 'neighbor 11.1.1.20', 'remote-as 65450', 'address-family ipv4 unicast', 'next-hop-self', '!', '!', '!', 'grpc', 'port 57777', 'no-tls', 'service-layer', '!', '!', 'telemetry model-driven', 'destination-group DGroup1', 'address-family ipv4 192.168.122.11 port 5432', 'encoding self-describing-gpb', 'protocol tcp', '!', '!', 'sensor-group SGroup1', 'sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters', '!', 'sensor-group IPV6Neighbor', 'sensor-path Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address', '!', 'subscription IPV6', 'sensor-group-id IPV6Neighbor sample-interval 15000', '!', 'subscription Sub1', 'sensor-group-id SGroup1 sample-interval 30000', 'destination-id DGroup1', '!', '!', 'netconf-yang agent', 'ssh', '!', 'ssh server v2', 'ssh server netconf vrf default', 'end']}&gt;&gt;&gt;Great! The running-config was returned as a list of lines. Let's pretty print this configuration.&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; pprint(ztp_obj.xrcmd(cmd))Building configuration...{'output'# ['!! IOS XR Configuration version = 6.4.1',            '!! Last configuration change at Sat Sep  8 19#07#36 2018 by ZTP',            '!',            'hostname r1',            'banner motd ;',            '--------------------------------------------------------------------------',            'Router 1 (Cisco IOS XR Sandbox)',            '--------------------------------------------------------------------------',            ';',            'logging console debugging',            'service timestamps log datetime msec',            'service timestamps debug datetime msec',            'username admin',            'group root-lr',            'group cisco-support',            'secret 5 $1$A4C9$oaNorr6BXDruE4gDd086L.',            '!',            'line console',            'timestamp disable',            'exec-timeout 0 0',            '!',            'vty-pool default 0 4 line-template VTY-TEMPLATE',            'call-home',            'service active',            'contact smart-licensing',            'profile CiscoTAC-1',            'active',            'destination transport-method http',            '!',            '!',            'interface MgmtEth0/RP0/CPU0/0',            'description *** MANAGEMENT INTERFACE ***',            'ipv4 address dhcp',            '!',            'interface GigabitEthernet0/0/0/0',            'ipv6 address 1010#1010##10/64',            'ipv6 enable',            '!',            'interface GigabitEthernet0/0/0/1',            'ipv6 address 2020#2020##10/64',            'ipv6 enable',            '!',            'interface GigabitEthernet0/0/0/2',            'shutdown',            '!',            'interface GigabitEthernet0/0/0/3',            'shutdown',            '!',            'interface GigabitEthernet0/0/0/4',            'shutdown',            '!',            'router static',            'address-family ipv4 unicast',            '0.0.0.0/0 10.0.2.2',            '1.2.3.5/32 10.0.2.2',            '!',            '!',            'router bgp 65400',            'bgp router-id 11.1.1.10',            'address-family ipv4 unicast',            'network 11.1.1.0/24',            '!',            'neighbor 11.1.1.20',            'remote-as 65450',            'address-family ipv4 unicast',            'next-hop-self',            '!',            '!',            '!',            'grpc',            'port 57777',            'no-tls',            'service-layer',            '!',            '!',            'telemetry model-driven',            'destination-group DGroup1',            'address-family ipv4 192.168.122.11 port 5432',            'encoding self-describing-gpb',            'protocol tcp',            '!',            '!',            'sensor-group SGroup1',            'sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters',            '!',            'sensor-group IPV6Neighbor',            'sensor-path Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address',            '!',            'subscription IPV6',            'sensor-group-id IPV6Neighbor sample-interval 15000',            '!',            'subscription Sub1',            'sensor-group-id SGroup1 sample-interval 30000',            'destination-id DGroup1',            '!',            '!',            'netconf-yang agent',            'ssh',            '!',            'ssh server v2',            'ssh server netconf vrf default',            'end'], 'status'# 'success'}&gt;&gt;&gt;You can clearly see that the response  is a dictionary that contains two fields# output and status. Since the exec_cmd was successfull executed, status=success and output=output of the exec/show command.The return values using the ztp python library utilities are very useful in deterministically writing CLI automation in python.Checking an invalid show commandUnlike the ZTP bash library, the ZTP python library does not put the onus of determining an invalid show command on the end user. Instead it returns status=error and output=% Invalid input detected at '^' marker..&gt;&gt;&gt; cmd={~exec_cmd~ # ~Hello World~}&gt;&gt;&gt; pprint(ztp_obj.xrcmd(cmd))showtech_helper error# Parsing of command ~Hello World~ failed{'output'# ['Hello World', '^', ~% Invalid input detected at '^' marker.~], 'status'# 'error'}&gt;&gt;&gt;Running an exec commandExec commands are essentially run in the exec mode and they can affect the state of the system unlike show commands that are read-only actions.For example, let’s say we want to clear the logs on the system. We can utilize xrcmd to do so. But in addition, exec commands usually offer prompts that must be handled as part of the xrcmd call. We do so by taking advantage of the prompt_response field in the dictionary passed into the xrcmd() method#Dump the initial set of logsYour logs at this stage could look completely different but dump the last 10 lines of the current logs to verify that the clearing process works (we do this using the python library as well)#&gt;&gt;&gt; cmd={~exec_cmd~ # ~show logging~}&gt;&gt;&gt; show_logging=ztp_obj.xrcmd(cmd)&gt;&gt;&gt;&gt;&gt;&gt; pprint(show_logging[~status~])'success'&gt;&gt;&gt;&gt;&gt;&gt; pprint(show_logging[~output~][-10#])[~RP/0/RP0/CPU0#Sep  8 19#07#34.182 UTC# config[68961]# %MGBL-CONFIG-6-DB_COMMIT # Configuration committed by user 'ZTP'. Use 'show configuration commit changes 1000000175' to view the changes.~, ~RP/0/RP0/CPU0#Sep  8 19#07#35.559 UTC# exec[69085]# %SECURITY-LOGIN-6-AUTHEN_SUCCESS # Successfully authenticated user 'ztp-user' from '&lt;unknown&gt;' on 'vty9'~, 'RP/0/RP0/CPU0#Sep  8 19#07#35.562 UTC# devc-vty[298]# The specified TTY (4, 9) is not registered in the DB', 'RP/0/RP0/CPU0#Sep  8 19#07#35.687 UTC# devc-vty[298]# The specified TTY (4, 9) is not registered in the DB', ~RP/0/RP0/CPU0#Sep  8 19#07#35.692 UTC# exec[69085]# %SECURITY-LOGIN-6-CLOSE # User 'ztp-user' logged out~, 'RP/0/RP0/CPU0#Sep  8 19#07#37.094 UTC# syslog_dev[119]# locald_DLRSC[327] PID-16853# passwd# password expiry information changed.', 'RP/0/RP0/CPU0#Sep  8 19#07#37.187 UTC# syslog_dev[119]# locald_DLRSC[327] PID-16877# Removing user ztp-user from group root-lr', ~RP/0/RP0/CPU0#Sep  8 19#07#39.156 UTC# config[69121]# %MGBL-CONFIG-6-DB_COMMIT # Configuration committed by user 'ZTP'. Use 'show configuration commit changes 1000000176' to view the changes.~, ~RP/0/RP0/CPU0#Sep  8 19#08#03.417 UTC# SSHD_[68000]# %SECURITY-SSHD-6-INFO_USER_LOGOUT # User 'admin' from '192.168.122.1' logged out on 'vty0'~, ~RP/0/RP0/CPU0#Sep  8 19#08#15.515 UTC# SSHD_[69282]# %SECURITY-SSHD-6-INFO_SUCCESS # Successfully authenticated user 'admin' from '192.168.122.1' on 'vty0'(cipher 'aes128-ctr', mac 'hmac-sha2-256')~]&gt;&gt;&gt;Clear the logs using xrcmdclear logging as an exec command prompts the user like so#RP/0/RP0/CPU0#r1#clear loggingMon Aug 20 01#58#14.572 UTCClear logging buffer [confirm] [y/n] #So to automate against this, simply provide “y\\n” as a prompt_response field in the xrcmd() input dictionary#&gt;&gt;&gt; cmd={~exec_cmd~ # ~clear logging~, ~prompt_response~ # ~y\\n~}&gt;&gt;&gt; ztp_obj.xrcmd(cmd){'status'# 'success', 'output'# ['Clear logging buffer [confirm] [y/n] #']}&gt;&gt;&gt;Great! Now checking the output of “show logging” again#&gt;&gt;&gt; cmd={~exec_cmd~ # ~show logging~}&gt;&gt;&gt; show_logging=ztp_obj.xrcmd(cmd)&gt;&gt;&gt;&gt;&gt;&gt; pprint(show_logging[~status~])'success'&gt;&gt;&gt; pprint(show_logging[~output~][-10#])['Syslog logging# enabled (0 messages dropped, 0 flushes, 0 overruns)', 'Console logging# level debugging, 9948 messages logged', 'Monitor logging# level debugging, 9610 messages logged', 'Trap logging# level informational, 0 messages logged', 'Buffer logging# level debugging, 0 messages logged', 'Log Buffer (2097152 bytes)#']&gt;&gt;&gt;The log buffer has been cleared!Running admin commandsIn IOS-XR the admin mode is a privileged mode that allows you to run certain administrative exec commands like reloading or shutting down the box, running privileged show commands like “admin show environment power” etc.To accomplish this we rope in the ZTP Bash library (get acquainted with ZTP Bash library through the first lab in this CLI Automation module) to execute the admin command using Python’s Subprocess module.Let us first define an admincmd()  utility of our own.Drop into the bash shell of router r1 again and create a run_admin_cmd.py file that contains the following code (you can use vi to accomplish this on the box itself)#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#bashSun Sep  9 00#12#24.569 UTC[r1#~]$[r1#~]$ cat run_admin_cmd.py#!/usr/bin/env pythonimport subprocessdef admincmd(root_lr_user=None, cmd=None)#    if cmd is None#        return {~status~ # ~error~, ~output~ # ~No command specified~}    if root_lr_user is None#        return {~status~ # ~error~, ~output~ # ~root-lr user not specified~}    status = ~success~    # Set up the AAA_USER environment variable to set up    # task map for admin cmd execution    export_aaa_user=~export AAA_USER=~+root_lr_user    # Source ztp_helper.sh ZTP Bash library to make sure that    # the xrcmd bash command is available    source_ztp_bash=~source /pkg/bin/ztp_helper.sh~    # Combine the two shell commands    cmd_env_setup=export_aaa_user+ ~&amp;&amp;~ +source_ztp_bash    # Set up use of xrcmd and echo to funnel in admin commands    # to the admin shell of IOS-XR    run_admin_cmd=~echo -ne \\~~+cmd+~\\\\n \\~ | xrcmd \\~admin\\~~    #Set up the final bash command to run    cmd = cmd_env_setup+ ~&amp;&amp;~ +run_admin_cmd    # Utilize SubProcess to run the shell command    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)    out, err = process.communicate()    # Filter out invalid admin exec/show commands and construct list out of output    if process.returncode#        status = ~error~        output = ~Failed to get command output~    else#        output_list = []        output = ~~        for line in out.splitlines()#            fixed_line= line.replace(~\\n~, ~ ~).strip()            output_list.append(fixed_line)            if ~syntax error# expecting~ in fixed_line#                status = ~error~            output = filter(None, output_list)    # Removing empty items    # Return the result with status and output    return {~status~ # status, ~output~ # output}[r1#~]$Here, we have created our own python function to run an admincmd in IOS-XR. Walk through the code comments to understand the flow of the code in greater detail.Now open up a python interpreter in the same directory as the run_admin_cmd.py file and import the admincmd() function we just created#[r1#~]$[r1#~]$ pythonPython 2.7.3 (default, Dec 12 2017, 08#22#03)[GCC 4.9.1] on linux2Type ~help~, ~copyright~, ~credits~ or ~license~ for more information.&gt;&gt;&gt;&gt;&gt;&gt; from run_admin_cmd import admincmdWe are now ready to run some admin commands through the python interpreter shell.We’ll try to run a simple show command in the admin mode#Running admin commands require a root-lr user to be configured on the router and an environment variable AAA_USER is used along with ZTP bash hooks to enable privilege associated with the root-lr user to gain access to the admin mode. Since the router has `admin` configured as the root-lr user, we set `root_lr_user`=`admin`[r1#~]$ pythonPython 2.7.3 (default, Dec 12 2017, 08#22#03)[GCC 4.9.1] on linux2Type ~help~, ~copyright~, ~credits~ or ~license~ for more information.&gt;&gt;&gt;&gt;&gt;&gt; from run_admin_cmd import admincmd&gt;&gt;&gt;&gt;&gt;&gt; result = admincmd(root_lr_user=~admin~, cmd=~show platform~)&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; pprint(result){'output'# ['ztp-user connected from 127.0.0.1 using console on r1',            '\\x1b[?7hsysadmin-vm#0_RP0#show platform',            'Sun Sep  9  00#17#29.516 UTC',            'Location  Card Type               HW State      SW State      Config State',            '----------------------------------------------------------------------------',            '0/0       R-IOSXRV9000-LC-C       OPERATIONAL   N/A           NSHUT',            '0/RP0     R-IOSXRV9000-RP-C       OPERATIONAL   OPERATIONAL   NSHUT',            'sysadmin-vm#0_RP0#'], 'status'# 'success'}&gt;&gt;&gt;Perfect! we can now proceed with the configuration manipulation hooks.Configuration MergeThere are 2 different utilities that allow you to play around with configuration merge on IOS-XR#xrapply()xrapply_string()Let’s try each one of these out. We’ve already seen the existing configuration, so let’s use the config merge utilities one by one to bring up four GigabitEthernet Interfaces on r1.Important# We expect the user to perform the same exact steps on r2 before we head to the next section! Remember interfaces on both the routers should be up before we try to bring up protocols on the box using a python script we will develop in the next sectionUsing xrapply() to bring up GigabitEthernet0/0/0/0xrapply uses a configuration file as an argument.So let’s create a file in the IOS-XR shell with the following content#Create the local configuration file[r1#~]$ pythonPython 2.7.3 (default, Dec 12 2017, 08#22#03)[GCC 4.9.1] on linux2Type ~help~, ~copyright~, ~credits~ or ~license~ for more information.&gt;&gt;&gt; file_path=~/root/gig0up.conf~&gt;&gt;&gt;&gt;&gt;&gt; file_content=~~~... !... interface GigabitEthernet0/0/0/0...   ipv4 address 10.1.1.10/24...   no shutdown... !... end... ~~~&gt;&gt;&gt;&gt;&gt;&gt;with open(file_path, 'w') as fd#...     fd.write(file_content)...&gt;&gt;&gt;   You could use vi for this purpose as well. In the end the file looks something like#[r1#~]$ cat /root/gig0up.conf!interface GigabitEthernet0/0/0/0  ipv4 address 10.1.1.10/24  no shutdown!end[r1#~]$Now xrapply() will add this configuration to the pre-existing configuration and will bring up GigabitEthernet0/0/0/0 with the ip address 100.1.1.10/24.Import  ZtpHelpers from /pkg/bin/ztp_helper.pyIn the python interpreter#&gt;&gt;&gt; sys.path.append(~/pkg/bin~)&gt;&gt;&gt; from ztp_helper import ZtpHelpers&gt;&gt;&gt; ztp_obj=ZtpHelpers()Do a configuration merge using xrapply&gt;&gt;&gt; response=ztp_obj.xrapply(filename=file_path)Building configuration...&gt;&gt;&gt; response{'status'# 'success', 'output'# ['!! IOS XR Configuration version = 6.4.1', 'interface GigabitEthernet0/0/0/0', 'ipv4 address 100.1.1.10 255.255.255.0', 'no shutdown', '!', 'end']}&gt;&gt;&gt;Check the return value&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt; pprint(response){'output'# ['!! IOS XR Configuration version = 6.4.1',            'interface GigabitEthernet0/0/0/0',            'ipv4 address 100.1.1.10 255.255.255.0',            'no shutdown',            '!',            'end'], 'status'# 'success'}&gt;&gt;&gt;The configuration merge was successful (status in the response) and the output field contains the contents of the  last configuration merge.Using xrapply with an invalid Configuration fileJust for kicks, let’s see what happens if we create an invalid configuration file and try to use xrapply#Create an invalid configuration filewithout leaving the python interpreter#&gt;&gt;&gt;&gt;&gt;&gt; invalid_config_filepath=~/root/invalid_config_file~&gt;&gt;&gt;&gt;&gt;&gt; file_content=~~~... !... interface invalid-interface-name...   ipv4 address 1.1.1.2/24...   no shutdown... !... end... ~~~&gt;&gt;&gt;&gt;&gt;&gt; with open(invalid_config_filepath, 'w') as fd#...     fd.write(file_content)...&gt;&gt;&gt;Do a config merge using xrapply&gt;&gt;&gt;&gt;&gt;&gt; response = ztp_obj.xrapply(filename=invalid_config_filepath)&gt;&gt;&gt;&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt;&gt;&gt;&gt; pprint(response){'output'# ['!! SYNTAX/AUTHORIZATION ERRORS# This configuration failed due to',            '!! one or more of the following reasons#',            '!!  - the entered commands do not exist,',            '!!  - the entered commands have errors in their syntax,',            '!!  - the software packages containing the commands are not active,',            '!!  - the current user is not a member of a task-group that has',            '!!    permissions to use the commands.',            'interface invalid-interface-name',            'ipv4 address 1.1.1.2/24',            'no shutdown'], 'status'# 'error'}&gt;&gt;&gt;Great! it throws up an error as expected. With the help of the return value, we can write more deteministic code to address configuration errors in our scripts.Using xrapply_string() with the reason parameter to configure GigabitEthernet0/0/0/1The steps are illustrated below. In this case the reason parameter is passed to the python utility as an option. The python interpreter we opened earlier continues to be utilized.&gt;&gt;&gt;&gt;&gt;&gt; gig1up_config=~~~... !... interface GigabitEthernet0/0/0/1...   ipv4 address 11.1.1.10/24...   no shutdown... !... end... ~~~&gt;&gt;&gt;&gt;&gt;&gt; print(gig1up_config)!interface GigabitEthernet0/0/0/3  ipv4 address 11.1.1.10/24  no shutdown!end&gt;&gt;&gt;&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(~/pkg/bin~)&gt;&gt;&gt; from ztp_helper import ZtpHelpers&gt;&gt;&gt; ztp_obj=ZtpHelpers()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reason_string = ~Testing python xrapply_string() with the reason parameter~&gt;&gt;&gt;&gt;&gt;&gt; response = ztp_obj.xrapply_string(cmd=gig3up_config, reason=reason_string)                    Building configuration...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from pprint import pprint&gt;&gt;&gt;&gt;&gt;&gt; pprint(response){'output'# ['!! IOS XR Configuration version = 6.4.1',            'interface GigabitEthernet0/0/0/3',            'ipv4 address 11.1.1.10 255.255.255.0',            'no shutdown',            '!',            'end'], 'status'# 'success'}&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; response = ztp_obj.xrcmd({~exec_cmd~ # ~show configuration commit list 1 detail~})&gt;&gt;&gt;&gt;&gt;&gt; pprint(response){'output'# ['1) CommitId# 1000000184                 Label# NONE',            'UserId#   ZTP                        Line#  ZTP',            'Client#   CLI                        Time#  Sun Sep  9 02#16#46 2018',            'Comment#  Testing python xrapply_string() with the reason parameter'], 'status'# 'success'}&gt;&gt;&gt;&gt;&gt;&gt;Configuration ReplaceVery Very Important# Configuration Replace can be potentially dangerous. If you make a mistake with the type of configuration you want to enforce, you can potentially lose connectivity to the router. So make sure you take precautions to ensure the final config is what you want at the end of the processWe will not be attempting an xrreplace as part of this lab. But The basic workflow for using xrreplace is the same as xrapply. Provide a file containing the config to xrreplace and upon execution it will replace the entire configuration on the router with the configuration specified in the file.",
      "url": "/wkinstructions/2019-02-01-step-2-playing-with-the-onbox-ios-xr-ztp-bash-library/",
      "author": "Akshat Sharma",
      "tags": "iosxr, cisco, ztp, lab"
    }
    
    ,
  
  
  
    "wkinstructions-2019-02-01-step-3-ios-xr-ztp-bash-and-python-hooks": {
      "title": "Step 3: IOS-XR ZTP Bash and Python hooks (+Ansible!)",
      "content": "     On This Page  To Know More  SSH into the devbox  Bash ZTP script          Transfer the bash script to Router r1 over SSH      Execute the bash script on router r1 over SSH      Transfer the bash script to Router r2 over SSH      Execute the bash script on router r2 over SSH        Install Ansible on the DevBox  Python ZTP hooks          Execute python ZTP script using Ansible      Dump the contents of the Ansible playbook      Run the Ansible playbook        To Know MoreAs part of the Zero-touch provisioning infrastructure, IOS-XR provides the option to automate CLI operations in either bash or python in the IOS-XR shell environment. This enables a large variety of integrations - including native scripts and offbox integrations with tools like AnsibleComplete CLI support#  Automate CLI operations such as “show commands”, “config merge”, “config replace”  Available in bash and python# Choose the scripting language you prefer and integrate with ztp, cronjobs, onbox-apps and more  Connect to your Pod first! Make sure your Anyconnect VPN connection to the Pod assigned to you is active.  If you haven’t connected yet, check out the instructions to do so here#https#//sevt-sp.github.io/xr-programmability-lab/connect-to-pods/  Once you’re connected, use the following instructions to connect to the individual nodes.The instructions in the workshop will simply refer to the Name of the box to connect withoutrepeating the connection details and credentials. So refer back to this list when you need it.  The 3 nodes in the topology are#  Development Linux System (DevBox)   IP Address# 10.10.20.170 Username/Password# [admin/admin] SSH Port# 2211    IOS-XRv9000 R1# (Router r1)  IP Address# 10.10.20.170  Username/Password# [admin/admin]   Management IP# 10.10.20.170  XR SSH Port# 2221    NETCONF Port# 8321   gRPC Port# 57021  XR-Bash SSH Port# 2222        IOS-XRv9000 R2#  (Router r2)  IP Address# 10.10.20.170   Username/Password# [admin/admin]   Management IP# 10.10.20.170   XR SSH Port# 2231    NETCONF Port# 8331   gRPC Port# 57031    XR-Bash SSH Port# 2232  The Topology in use is shown below#SSH into the devboxDrop into the devbox using the credentials above and clone the following git repository#  https#//github.com/sevt-sp/xr-programmability-lab-codeAKSHSHAR-M-33WP#~ akshshar$ AKSHSHAR-M-33WP#~ akshshar$ ssh -p 2211 admin@10.10.20.170admin@10.10.20.170's password# Last login# Tue Jan 29 18#33#43 2019 from 192.168.122.1admin@devbox#~$ admin@devbox#~$ admin@devbox#~$ admin@devbox#~$ git clone https#//github.com/sevt-sp/xr-programmability-lab-code.gitCloning into 'xr-programmability-lab-code'...remote# Enumerating objects# 33, done.remote# Counting objects# 100% (33/33), done.remote# Compressing objects# 100% (23/23), done.remote# Total 33 (delta 8), reused 33 (delta 8), pack-reused 0Unpacking objects# 100% (33/33), done.Checking connectivity... done.admin@devbox#~$ admin@devbox#~$ You should see the following files#admin@devbox#~$ cd xr-programmability-lab-code/admin@devbox#xr-programmability-lab-code$ tree ..├── ansible│   ├── ansible_hosts│   ├── configure_bgp_netconf.yml│   ├── docker_bringup.yml│   ├── execute_python_ztp.yml│   ├── openr│   │   ├── hosts_r1│   │   ├── hosts_r2│   │   ├── increment_ipv4_prefix1.py│   │   ├── increment_ipv4_prefix2.py│   │   ├── launch_openr_r1.sh│   │   ├── launch_openr_r2.sh│   │   ├── run_openr_r1.sh│   │   └── run_openr_r2.sh│   ├── set_ipv6_route.sh│   └── xml│       ├── r1-bgp.xml│       └── r2-bgp.xml├── README.md├── ydk│   ├── configure_telemetry_openconfig.py│   ├── nc-create-xr-ipv4-ospf-cfg-rtr1-ydk.py│   └── nc-create-xr-ipv4-ospf-cfg-rtr2-ydk.py└── ztp_hooks    ├── automate_cli_bash.sh    └── automate_cli_python.py5 directories, 21 filesadmin@devbox#xr-programmability-lab-code$ cd into the ztp_hooks directory and you should a couple of files we will deal with in this sectionadmin@devbox#xr-programmability-lab-code$ admin@devbox#xr-programmability-lab-code$ cd ztp_hooks/admin@devbox#ztp_hooks$ lsautomate_cli_bash.sh  automate_cli_python.pyadmin@devbox#ztp_hooks$ Bash ZTP scriptThe bash script will utilize the ZTP bash hooks in IOS-XR to configure Loopback0 and grpc on each router.Further it will configure and bring-up interfaces Gig0/0/0/0, Gig0/0/0/1 and Gig0/0/0/2 on each router. These are the b2b connected interfaces of the router r1 and r2.  To learn about all the ZTP Bash hooks available in IOS-XR use the following learning lab on DevNet#https#//learninglabs.cisco.com/tracks/iosxr-programmability/iosxr-cli-automation/01-iosxr-01-cli-automation-bash/step/1Transfer the bash script to Router r1 over SSHpassword for Router r1 is adminadmin@devbox#ztp_hooks$ admin@devbox#ztp_hooks$ pwd/home/admin/xr-programmability-lab-code/ztp_hooksadmin@devbox#ztp_hooks$ admin@devbox#ztp_hooks$ scp -P 2221 automate_cli_bash.sh  admin@10.10.20.170#/misc/scratch/--------------------------------------------------------------------------  Router 1 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password# automate_cli_bash.sh                                                                                   100%  838     0.8KB/s   00#00    Connection to 10.10.20.170 closed by remote host.admin@devbox#ztp_hooks$ Execute the bash script on router r1 over SSHadmin@devbox#ztp_hooks$ ssh -p 2221  admin@10.10.20.170 run /misc/scratch/automate_cli_bash.sh--------------------------------------------------------------------------  Router 1 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password# Wed Jan 30 06#03#41.016 UTCBuilding configuration...!! IOS XR Configuration version = 6.4.1interface Loopback0 ipv4 address 50.1.1.1 255.255.255.255!interface GigabitEthernet0/0/0/0 ipv4 address 10.1.1.10 255.255.255.0 ipv6 enable!interface GigabitEthernet0/0/0/1 ipv4 address 11.1.1.10 255.255.255.0 ipv6 enable!interface GigabitEthernet0/0/0/2 ipv4 address 12.1.1.10 255.255.255.0 ipv6 enable!grpc port 57777 no-tls service-layer !!endadmin@devbox#ztp_hooks$ Let’s do the same for router r2.Transfer the bash script to Router r2 over SSHadmin@devbox#ztp_hooks$ pwd/home/admin/xr-programmability-lab-code/ztp_hooksadmin@devbox#ztp_hooks$ admin@devbox#ztp_hooks$ admin@devbox#ztp_hooks$ scp -P 2231 automate_cli_bash.sh  admin@10.10.20.170#/misc/scratch/--------------------------------------------------------------------------  Router 2 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password# automate_cli_bash.sh                                                                                   100%  838     0.8KB/s   00#00    Connection to 10.10.20.170 closed by remote host.admin@devbox#ztp_hooks$ Execute the bash script on router r2 over SSHadmin@devbox#ztp_hooks$ ssh -p 2231  admin@10.10.20.170 run /misc/scratch/automate_cli_bash.sh--------------------------------------------------------------------------  Router 2 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password# Wed Jan 30 06#03#59.093 UTCBuilding configuration...!! IOS XR Configuration version = 6.4.1interface Loopback0 ipv4 address 60.1.1.1 255.255.255.255!interface GigabitEthernet0/0/0/0 ipv4 address 10.1.1.20 255.255.255.0 ipv6 enable!interface GigabitEthernet0/0/0/1 ipv4 address 11.1.1.20 255.255.255.0 ipv6 enable!interface GigabitEthernet0/0/0/2 ipv4 address 12.1.1.20 255.255.255.0 ipv6 enable!grpc port 57777 no-tls service-layer !!endadmin@devbox#ztp_hooks$  Great, so we know how to run ZTP-API based scripts on the box. In the steps above, we did so over SSH.But it can soon grow to be cumbersome, if you have to manually transfer the scripts to each router in the topology and then execute over SSH. Further, the manual password entry greatly reduces the speed at which these actions can be performed and is not a scalable automation technique.So for the python ZTP scripts we will deal with below, we scale out the process using AnsibleInstall Ansible on the DevBoxLet’s begin by installing Ansible on the Devbox. We will go with Ansible version=2.6.0 since it has been tested with this lab.admin@devbox#~$ sudo pip install ansible==2.6.0The directory '/home/admin/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/admin/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Collecting ansible==2.6.0  Downloading https#//files.pythonhosted.org/packages/c3/af/c86d456905284ecfce79736b55942470b42fdadea9150843e2eb51c2ecae/ansible-2.6.0.tar.gz (10.7MB)    100% |████████████████████████████████| 10.7MB 1.3MB/s Collecting jinja2 (from ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/7f/ff/ae64bacdfc95f27a016a7bed8e8686763ba4d277a78ca76f32659220a731/Jinja2-2.10-py2.py3-none-any.whl (126kB)    100% |████████████████████████████████| 133kB 20.9MB/s Collecting PyYAML (from ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/9e/a3/1d13970c3f36777c583f136c136f804d70f500168edc1edea6daa7200769/PyYAML-3.13.tar.gz (270kB)    100% |████████████████████████████████| 276kB 21.7MB/s Collecting paramiko (from ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/cf/ae/94e70d49044ccc234bfdba20114fa947d7ba6eb68a2e452d89b920e62227/paramiko-2.4.2-py2.py3-none-any.whl (193kB)    100% |████████████████████████████████| 194kB 24.0MB/s Collecting cryptography (from ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/98/71/e632e222f34632e0527dd41799f7847305e701f38f512d81bdf96009bca4/cryptography-2.5-cp34-abi3-manylinux1_x86_64.whl (2.4MB)    100% |████████████████████████████████| 2.4MB 13.8MB/s Requirement already satisfied# setuptools in /usr/lib/python3/dist-packages (from ansible==2.6.0) (20.7.0)Collecting MarkupSafe&gt;=0.23 (from jinja2-&gt;ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/3e/a5/e188980ef1d0a4e0788b5143ea933f9afd760df38fec4c0b72b5ae3060c8/MarkupSafe-1.1.0-cp35-cp35m-manylinux1_x86_64.whlCollecting bcrypt&gt;=3.1.3 (from paramiko-&gt;ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/d0/79/79a4d167a31cc206117d9b396926615fa9c1fdbd52017bcced80937ac501/bcrypt-3.1.6-cp34-abi3-manylinux1_x86_64.whl (55kB)    100% |████████████████████████████████| 61kB 12.8MB/s Collecting pynacl&gt;=1.0.1 (from paramiko-&gt;ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/27/15/2cd0a203f318c2240b42cd9dd13c931ddd61067809fee3479f44f086103e/PyNaCl-1.3.0-cp34-abi3-manylinux1_x86_64.whl (759kB)    100% |████████████████████████████████| 768kB 15.8MB/s Collecting pyasn1&gt;=0.1.7 (from paramiko-&gt;ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/7b/7c/c9386b82a25115cccf1903441bba3cbadcfae7b678a20167347fa8ded34c/pyasn1-0.4.5-py2.py3-none-any.whl (73kB)    100% |████████████████████████████████| 81kB 9.8MB/s Collecting asn1crypto&gt;=0.21.0 (from cryptography-&gt;ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/ea/cd/35485615f45f30a510576f1a56d1e0a7ad7bd8ab5ed7cdc600ef7cd06222/asn1crypto-0.24.0-py2.py3-none-any.whl (101kB)    100% |████████████████████████████████| 102kB 17.1MB/s Requirement already satisfied# six&gt;=1.4.1 in /usr/lib/python3/dist-packages (from cryptography-&gt;ansible==2.6.0) (1.10.0)Collecting cffi!=1.11.3,&gt;=1.8 (from cryptography-&gt;ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/59/cc/0e1635b4951021ef35f5c92b32c865ae605fac2a19d724fb6ff99d745c81/cffi-1.11.5-cp35-cp35m-manylinux1_x86_64.whl (420kB)    100% |████████████████████████████████| 430kB 18.0MB/s Collecting pycparser (from cffi!=1.11.3,&gt;=1.8-&gt;cryptography-&gt;ansible==2.6.0)  Downloading https#//files.pythonhosted.org/packages/68/9e/49196946aee219aead1290e00d1e7fdeab8567783e83e1b9ab5585e6206a/pycparser-2.19.tar.gz (158kB)    100% |████████████████████████████████| 163kB 12.5MB/s Installing collected packages# MarkupSafe, jinja2, PyYAML, asn1crypto, pycparser, cffi, cryptography, bcrypt, pynacl, pyasn1, paramiko, ansible  Running setup.py install for PyYAML ... done  Running setup.py install for pycparser ... done  Running setup.py install for ansible ... doneSuccessfully installed MarkupSafe-1.1.0 PyYAML-3.13 ansible-2.6.0 asn1crypto-0.24.0 bcrypt-3.1.6 cffi-1.11.5 cryptography-2.5 jinja2-2.10 paramiko-2.4.2 pyasn1-0.4.5 pycparser-2.19 pynacl-1.3.0You are using pip version 10.0.1, however version 19.0.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.admin@devbox#~$ Check the ansible version once installation is complete#admin@devbox#~$ ansible --versionansible 2.6.0  config file = /etc/ansible/ansible.cfg  configured module search path = ['/home/admin/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']  ansible python module location = /usr/local/lib/python3.5/dist-packages/ansible  executable location = /usr/local/bin/ansible  python version = 3.5.2 (default, Nov 12 2018, 13#43#14) [GCC 5.4.0 20160609]admin@devbox#~$ Python ZTP hooksThe python ZTP hooks script we intend to use is under ztp_hooks/ directory in the git repository we cloned earlier#admin@devbox#~$ admin@devbox#~$ cd ~/xr-programmability-lab-code/admin@devbox#xr-programmability-lab-code$ cd ztp_hooks/admin@devbox#ztp_hooks$ lsautomate_cli_bash.sh  automate_cli_python.pyadmin@devbox#ztp_hooks$Open up the script to understand the code as the execution takes place. You can open up another ssh session to the devbox in a separate terminal tab for this purpose.The script will use different ZTP python APIs in IOS-XR to do CLI operations such as xrcmd(Show commands) and xrapply(Merge configuration). xrreplace is not shown but it can be used to the Replace existing configuration with a specified snippet.Eventually the script will push the following configuration on each router#!! IOS XR Configuration version = 6.4.1domain name-server 8.8.8.8tpa vrf default  address-family ipv4   default-route mgmt   update-source dataports MgmtEth0/RP0/CPU0/0  ! !!endFurther the script will restart the docker daemon on the host for the routing changes to take effect and finally pull the docker image for Open/R to be run in the last section of the workshop.Execute python ZTP script using AnsibleHop into the ansible/ directory of the git repository we cloned earlier. The ansible playbook we intend to use is shown below (execute_python_ztp.yml)#Dump the contents of the Ansible playbookadmin@devbox#~$ cd xr-programmability-lab-code/admin@devbox#xr-programmability-lab-code$ lsansible  README.md  ztp_hooksadmin@devbox#xr-programmability-lab-code$ cd ansible/admin@devbox#ansible$ admin@devbox#ansible$ cat execute_python_ztp.yml ---- hosts# routers_shell   strategy# debug  become# yes  gather_facts# no  tasks#  - debug# msg=~hostname=~  - name# Copy and Execute the Python Configuration script on the router    script# ../ztp_hooks/automate_cli_python.py    register# output  - debug#        var# output.stdout_linesadmin@devbox#ansible$ Run the Ansible playbook  IMPORTANT# Before you run the ansible playbook, make sure you set the &gt;ANSIBLE_HOST_KEY_CHECKING environment variable to false to allow Ansible to easily connect without being stalled by keychecking requirements for the two routers. This can also be set in the ansible_cfg file instead.  admin@devbox#ansible$ admin@devbox#ansible$ export ANSIBLE_HOST_KEY_CHECKING=False    {# .notice–danger} .Now, execute the ansible playbook, which will automatically transfer the python script to the shell of each router based on the ansible_hosts file which stores the credentials and connection information.admin@devbox#ansible$ admin@devbox#ansible$ cat ansible_hosts [routers_shell]r1 ansible_user=~admin~ ansible_password=~admin~ ansible_sudo_pass=~admin~ ansible_host=10.10.20.170 ansible_port=2222 hostname=r1 netconf_port=8321 xml_file=~./xml/r1-bgp.xml~ run_openr_script=~./openr/run_openr_r1.sh~ launch_openr_script=~./openr/launch_openr_r1.sh~ hosts_r=~./openr/hosts_r1~ increment_ipv4_prefix=~./openr/increment_ipv4_prefix1.py~ cron_file=~./set_ipv6_route.sh~r2 ansible_user=~admin~ ansible_sudo_pass=~admin~ ansible_password=~admin~ ansible_host=10.10.20.170 ansible_port=2232 hostname=r2 netconf_port=8331 xml_file=~./xml/r2-bgp.xml~ run_openr_script=~./openr/run_openr_r2.sh~ launch_openr_script=~./openr/launch_openr_r2.sh~ hosts_r=~./openr/hosts_r2~ increment_ipv4_prefix=~./openr/increment_ipv4_prefix2.py~ cron_file=~./set_ipv6_route.sh~admin@devbox#ansible$ When we run the playbook, wait for some time before the ansible-playbook returns the output of the script run on each router#admin@devbox#ansible$ admin@devbox#ansible$ ansible-playbook -i ansible_hosts execute_python_ztp.ymlPLAY [routers_shell] ******************************************************************************************************************TASK [debug] **************************************************************************************************************************ok# [r2] =&gt; {    ~msg~# ~hostname=r2~}ok# [r1] =&gt; {    ~msg~# ~hostname=r1~}TASK [Copy and Execute the Python Configuration script on the router] *****************************************************************changed# [r2]changed# [r1]TASK [debug] **************************************************************************************************************************ok# [r1] =&gt; {    ~output.stdout_lines~# [        ~~,         ~###### Debugs enabled ######~,         ~~,         ~~,         ~###### Using Child class method, creating a new user ######~,         ~~,         ~2019-01-30 13#41#42,652 - DebugZTPLogger - DEBUG - Config File content to be applied  !~,         ~                     username vagrant ~,         ~                     group root-lr~,         ~                     group cisco-support~,         ~                     secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1 ~,         ~                     !~,         ~                     end~,         ~2019-01-30 13#41#48,489 - DebugZTPLogger - DEBUG - Received exec command request# \\~show configuration commit changes last 1\\~~,         ~2019-01-30 13#41#48,489 - DebugZTPLogger - DEBUG - Response to any expected prompt \\~\\~~,         ~Building configuration...~,         ~2019-01-30 13#41#50,291 - DebugZTPLogger - DEBUG - Exec command output is ['!! IOS XR Configuration version = 6.4.1', 'username vagrant', 'group root-lr', 'group cisco-support', 'secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1', '!', 'end']~,         ~2019-01-30 13#41#50,291 - DebugZTPLogger - DEBUG - Config apply through file successful, last change = ['!! IOS XR Configuration version = 6.4.1', 'username vagrant', 'group root-lr', 'group cisco-support', 'secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1', '!', 'end']~,         ~~,         ~###### New user successfully created, return value# ######~,         ~~,         ~['!! IOS XR Configuration version = 6.4.1',~,         ~ 'username vagrant',~,         ~ 'group root-lr',~,         ~ 'group cisco-support',~,         ~ 'secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1',~,         ~ '!',~,         ~ 'end']~,         ~~,         ~###### return value in json# ######~,         ~~,         ~[~,         ~    \\~!! IOS XR Configuration version = 6.4.1\\~, ~,         ~    \\~username vagrant\\~, ~,         ~    \\~group root-lr\\~, ~,         ~    \\~group cisco-support\\~, ~,         ~    \\~secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1\\~, ~,         ~    \\~!\\~, ~,         ~    \\~end\\~~,         ~]~,         ~~,         ~###### Debugs Disabled  ######~,         ~~,         ~~,         ~###### Applying an incorrect config  ######~,         ~~,         ~~,         ~###### Failed to apply configuration, error is#######~,         ~~,         ~['!! SYNTAX/AUTHORIZATION ERRORS# This configuration failed due to',~,         ~ '!! one or more of the following reasons#',~,         ~ '!!  - the entered commands do not exist,',~,         ~ '!!  - the entered commands have errors in their syntax,',~,         ~ '!!  - the software packages containing the commands are not active,',~,         ~ '!!  - the current user is not a member of a task-group that has',~,         ~ '!!    permissions to use the commands.',~,         ~ 'domain nameserver 8.8.8.8']~,         ~~,         ~###### error in json# ######~,         ~~,         ~[~,         ~    \\~!! SYNTAX/AUTHORIZATION ERRORS# This configuration failed due to\\~, ~,         ~    \\~!! one or more of the following reasons#\\~, ~,         ~    \\~!!  - the entered commands do not exist,\\~, ~,         ~    \\~!!  - the entered commands have errors in their syntax,\\~, ~,         ~    \\~!!  - the software packages containing the commands are not active,\\~, ~,         ~    \\~!!  - the current user is not a member of a task-group that has\\~, ~,         ~    \\~!!    permissions to use the commands.\\~, ~,         ~    \\~domain nameserver 8.8.8.8\\~~,         ~]~,         ~~,         ~###### Applying the correct config  ######~,         ~~,         ~Building configuration...~,         ~~,         ~###### Successfully applied configuration, checking last commit######~,         ~~,         ~Building configuration...~,         ~['!! IOS XR Configuration version = 6.4.1',~,         ~ 'domain name-server 8.8.8.8',~,         ~ 'end']~,         ~~,         ~###### last commit in json# ######~,         ~~,         ~[~,         ~    \\~!! IOS XR Configuration version = 6.4.1\\~, ~,         ~    \\~domain name-server 8.8.8.8\\~, ~,         ~    \\~end\\~~,         ~]~,         ~~,         ~####### Applying tpa configuration to enable docker pull from docker.io######~,         ~~,         ~Building configuration...~,         ~~,         ~###### tpa config successfully applied, response# ######~,         ~~,         ~['!! IOS XR Configuration version = 6.4.1',~,         ~ 'tpa',~,         ~ 'vrf default',~,         ~ 'address-family ipv4',~,         ~ 'default-route mgmt',~,         ~ 'update-source dataports MgmtEth0/RP0/CPU0/0',~,         ~ '!',~,         ~ '!',~,         ~ '!',~,         ~ 'end']~,         ~~,         ~###### return value in json# ######~,         ~~,         ~[~,         ~    \\~!! IOS XR Configuration version = 6.4.1\\~, ~,         ~    \\~tpa\\~, ~,         ~    \\~vrf default\\~, ~,         ~    \\~address-family ipv4\\~, ~,         ~    \\~default-route mgmt\\~, ~,         ~    \\~update-source dataports MgmtEth0/RP0/CPU0/0\\~, ~,         ~    \\~!\\~, ~,         ~    \\~!\\~, ~,         ~    \\~!\\~, ~,         ~    \\~end\\~~,         ~]~,         ~~,         ~####### Finally restarting the docker daemon to make sure changes take effect######~,         ~~,         ~~,         ~###### Successfully restarted the docker daemon, response# ######~,         ~~,         ~['ztp-user connected from 127.0.0.1 using console on r1',~,         ~ '\\\\x1b[?7hsysadmin-vm#0_RP0# run ssh 10.0.2.16 service docker restart',~,         ~ 'Wed Jan  30 13#42#16.788 UTC',~,         ~ 'docker stop/waiting',~,         ~ 'docker start/running, process 18840',~,         ~ 'sysadmin-vm#0_RP0#']~,         ~~,         ~###### return value in json# ######~,         ~~,         ~[~,         ~    \\~ztp-user connected from 127.0.0.1 using console on r1\\~, ~,         ~    \\~\\\\u001b[?7hsysadmin-vm#0_RP0# run ssh 10.0.2.16 service docker restart\\~, ~,         ~    \\~Wed Jan  30 13#42#16.788 UTC\\~, ~,         ~    \\~docker stop/waiting\\~, ~,         ~    \\~docker start/running, process 18840\\~, ~,         ~    \\~sysadmin-vm#0_RP0#\\~~,         ~]~,         ~Sleeping for about 30 seconds, waiting for the docker daemon to be up~,         ~~,         ~#######Pulling the docker image for Open/R ######~,         ~~,         ~{'status'# 1, 'output'# 'Using default tag# latest\\\\n', 'error'# 'Error response from daemon# Get https#//registry-1.docker.io/v2/akshshar/openr-xr/manifests/latest# Get https#//auth.docker.io/token?scope=repository%3Aakshshar%2Fopenr-xr%3Apull&amp;service=registry.docker.io# net/http# request canceled while waiting for connection\\\\n'}~    ]}ok# [r2] =&gt; {    ~output.stdout_lines~# [        ~~,         ~###### Debugs enabled ######~,         ~~,         ~~,         ~###### Using Child class method, creating a new user ######~,         ~~,         ~2019-01-30 13#41#42,159 - DebugZTPLogger - DEBUG - Config File content to be applied  !~,         ~                     username vagrant ~,         ~                     group root-lr~,         ~                     group cisco-support~,         ~                     secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1 ~,         ~                     !~,         ~                     end~,         ~2019-01-30 13#41#47,312 - DebugZTPLogger - DEBUG - Received exec command request# \\~show configuration commit changes last 1\\~~,         ~2019-01-30 13#41#47,313 - DebugZTPLogger - DEBUG - Response to any expected prompt \\~\\~~,         ~Building configuration...~,         ~2019-01-30 13#41#49,057 - DebugZTPLogger - DEBUG - Exec command output is ['!! IOS XR Configuration version = 6.4.1', 'username vagrant', 'group root-lr', 'group cisco-support', 'secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1', '!', 'end']~,         ~2019-01-30 13#41#49,057 - DebugZTPLogger - DEBUG - Config apply through file successful, last change = ['!! IOS XR Configuration version = 6.4.1', 'username vagrant', 'group root-lr', 'group cisco-support', 'secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1', '!', 'end']~,         ~~,         ~###### New user successfully created, return value# ######~,         ~~,         ~['!! IOS XR Configuration version = 6.4.1',~,         ~ 'username vagrant',~,         ~ 'group root-lr',~,         ~ 'group cisco-support',~,         ~ 'secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1',~,         ~ '!',~,         ~ 'end']~,         ~~,         ~###### return value in json# ######~,         ~~,         ~[~,         ~    \\~!! IOS XR Configuration version = 6.4.1\\~, ~,         ~    \\~username vagrant\\~, ~,         ~    \\~group root-lr\\~, ~,         ~    \\~group cisco-support\\~, ~,         ~    \\~secret 5 $1$FzMk$Y5G3Cv0H./q0fG.LGyIJS1\\~, ~,         ~    \\~!\\~, ~,         ~    \\~end\\~~,         ~]~,         ~~,         ~###### Debugs Disabled  ######~,         ~~,         ~~,         ~###### Applying an incorrect config  ######~,         ~~,         ~~,         ~###### Failed to apply configuration, error is#######~,         ~~,         ~['!! SYNTAX/AUTHORIZATION ERRORS# This configuration failed due to',~,         ~ '!! one or more of the following reasons#',~,         ~ '!!  - the entered commands do not exist,',~,         ~ '!!  - the entered commands have errors in their syntax,',~,         ~ '!!  - the software packages containing the commands are not active,',~,         ~ '!!  - the current user is not a member of a task-group that has',~,         ~ '!!    permissions to use the commands.',~,         ~ 'domain nameserver 8.8.8.8']~,         ~~,         ~###### error in json# ######~,         ~~,         ~[~,         ~    \\~!! SYNTAX/AUTHORIZATION ERRORS# This configuration failed due to\\~, ~,         ~    \\~!! one or more of the following reasons#\\~, ~,         ~    \\~!!  - the entered commands do not exist,\\~, ~,         ~    \\~!!  - the entered commands have errors in their syntax,\\~, ~,         ~    \\~!!  - the software packages containing the commands are not active,\\~, ~,         ~    \\~!!  - the current user is not a member of a task-group that has\\~, ~,         ~    \\~!!    permissions to use the commands.\\~, ~,         ~    \\~domain nameserver 8.8.8.8\\~~,         ~]~,         ~~,         ~###### Applying the correct config  ######~,         ~~,         ~Building configuration...~,         ~~,         ~###### Successfully applied configuration, checking last commit######~,         ~~,         ~Building configuration...~,         ~['!! IOS XR Configuration version = 6.4.1',~,         ~ 'domain name-server 8.8.8.8',~,         ~ 'end']~,         ~~,         ~###### last commit in json# ######~,         ~~,         ~[~,         ~    \\~!! IOS XR Configuration version = 6.4.1\\~, ~,         ~    \\~domain name-server 8.8.8.8\\~, ~,         ~    \\~end\\~~,         ~]~,         ~~,         ~####### Applying tpa configuration to enable docker pull from docker.io######~,         ~~,         ~Building configuration...~,         ~~,         ~###### tpa config successfully applied, response# ######~,         ~~,         ~['!! IOS XR Configuration version = 6.4.1',~,         ~ 'tpa',~,         ~ 'vrf default',~,         ~ 'address-family ipv4',~,         ~ 'default-route mgmt',~,         ~ 'update-source dataports MgmtEth0/RP0/CPU0/0',~,         ~ '!',~,         ~ '!',~,         ~ '!',~,         ~ 'end']~,         ~~,         ~###### return value in json# ######~,         ~~,         ~[~,         ~    \\~!! IOS XR Configuration version = 6.4.1\\~, ~,         ~    \\~tpa\\~, ~,         ~    \\~vrf default\\~, ~,         ~    \\~address-family ipv4\\~, ~,         ~    \\~default-route mgmt\\~, ~,         ~    \\~update-source dataports MgmtEth0/RP0/CPU0/0\\~, ~,         ~    \\~!\\~, ~,         ~    \\~!\\~, ~,         ~    \\~!\\~, ~,         ~    \\~end\\~~,         ~]~,         ~~,         ~####### Finally restarting the docker daemon to make sure changes take effect######~,         ~~,         ~~,         ~###### Successfully restarted the docker daemon, response# ######~,         ~~,         ~['ztp-user connected from 127.0.0.1 using console on r2',~,         ~ '\\\\x1b[?7hsysadmin-vm#0_RP0# run ssh 10.0.2.16 service docker restart',~,         ~ 'Wed Jan  30 13#42#14.295 UTC',~,         ~ 'docker stop/waiting',~,         ~ 'docker start/running, process 13980',~,         ~ 'sysadmin-vm#0_RP0#']~,         ~~,         ~###### return value in json# ######~,         ~~,         ~[~,         ~    \\~ztp-user connected from 127.0.0.1 using console on r2\\~, ~,         ~    \\~\\\\u001b[?7hsysadmin-vm#0_RP0# run ssh 10.0.2.16 service docker restart\\~, ~,         ~    \\~Wed Jan  30 13#42#14.295 UTC\\~, ~,         ~    \\~docker stop/waiting\\~, ~,         ~    \\~docker start/running, process 13980\\~, ~,         ~    \\~sysadmin-vm#0_RP0#\\~~,         ~]~,         ~Sleeping for about 30 seconds, waiting for the docker daemon to be up~,         ~~,         ~#######Pulling the docker image for Open/R ######~,         ~~,         ~{'status'# 0, 'output'# 'Using default tag# latest\\\\nlatest# Pulling from akshshar/openr-xr\\\\nDigest# sha256#0d81b575830fe776739f960870652c7d9da601eaf32f68fa5569e852a2c5d4b0\\\\nStatus# Image is up to date for akshshar/openr-xr#latest\\\\n', 'error'# ''}~    ]}PLAY RECAP ****************************************************************************************************************************r1                         # ok=3    changed=1    unreachable=0    failed=0   r2                         # ok=3    changed=1    unreachable=0    failed=0   admin@devbox#ansible$ admin@devbox#ansible$Perfect! We’re all set for the next section of the lab where will look to levarage IOS-XR Yang models to configure BGP and set up a telemetry session.",
      "url": "/wkinstructions/2019-02-01-step-3-ios-xr-ztp-bash-and-python-hooks/",
      "author": "Akshat Sharma",
      "tags": "iosxr, cisco, devnet, CLUS2018, programmability"
    }
    
    ,
  
  
  
    "wkinstructions-2019-02-01-step-4-quick-look-at-model-driven-telemetry-on-ios-xr": {
      "title": "Step 4: Quick look at Model Driven Telemetry on IOS-XR",
      "content": "     On This Page  Setting up a Telemetry Client/Collector          Open-Source tool# Pipeline                  Supported Capabilities                    Testing Telemetry Yang Paths on-box                  Set up IPv6 Neighbors                          Configure IPv6 on router r1              Configure IPv6 on router r2              Bring up IPv6 neighbors              Ping the reachable Neighbors              Verify neighbors are up                                Configure Telemetry to Stream IPv6 neighbor information          Figure out the Yang Model/Path to use          Setting up the Telemetry configuration                    Testing the Sensor path      Building your own clients      Clean up!          Have a look at the set of Telemetry learning labs on DevNet for more details on Telemetry,available workflows, configurations and usage of tools#https#//learninglabs.cisco.com/modules/iosxr-streaming-telemetrySetting up a Telemetry Client/CollectorLet’s consider the options available to set up a Telemetry client/collector that can receive Streaming data from the router.Open-Source tool# PipelinePipeline is a flexible, multi-function collection service that is written in Go. It can ingest telemetry data from any XR release starting from 6.0.1. Pipeline’s input stages support raw UDP and TCP, as well as gRPC dial-in and dial-out capability. For encoding, Pipeline can consume JSON, compact GPB and self-describing GPB. On the output side, Pipeline can write the telemetry data to a text file as a JSON object, push the data to a Kafka bus and/or format it for consumption by open source stacks. Pipeline can easily be extended to include other output stages and we encourage contributions from anyone who wants to get involved.It’s important to understand that Pipeline is not a complete big data analytics stack. Think of it as the first layer in a scalable, modular, analytics architecture. Depending on your use case, that architecture would also include separate components for big data storage, stream processing, analysis, alerting and visualization.Supported CapabilitiesPipeline is the most comprehensive tool available for IOS-XR telemetry data consumption. It is Golang–based code which consumes IOS XR telemetry streams directly from routers or indirectly from a pub/sub bus (Kafka). Once collected, Pipeline performs transformations of the data and forwards the result to the configured consumer.Pipeline supports different input transport formats from routers (please be aware that multiple input modules of any type can run in parallel)#  TCP  gRPC  UDP  Apache KafkaPipeline can support different encodings as well#  (compact) GPB  KV-GPB  JSONPipeline can stream data to several different consumers. Supported downstream consumers include#  InfluxDB (TSDB)  Prometheus (TSDB)  Apache Kafka  dump-to-file (mostly for diagnostics purposes)  Connect to your Pod first! Make sure your Anyconnect VPN connection to the Pod assigned to you is active.  If you haven’t connected yet, check out the instructions to do so here#https#//sevt-sp.github.io/xr-programmability-lab/connect-to-pods/  Once you’re connected, use the following instructions to connect to the individual nodes.The instructions in the workshop will simply refer to the Name of the box to connect withoutrepeating the connection details and credentials. So refer back to this list when you need it.  The 3 nodes in the topology are#  Development Linux System (DevBox)   IP Address# 10.10.20.170 Username/Password# [admin/admin] SSH Port# 2211    IOS-XRv9000 R1# (Router r1)  IP Address# 10.10.20.170  Username/Password# [admin/admin]   Management IP# 10.10.20.170  XR SSH Port# 2221    NETCONF Port# 8321   gRPC Port# 57021  XR-Bash SSH Port# 2222        IOS-XRv9000 R2#  (Router r2)  IP Address# 10.10.20.170   Username/Password# [admin/admin]   Management IP# 10.10.20.170   XR SSH Port# 2231    NETCONF Port# 8331   gRPC Port# 57031    XR-Bash SSH Port# 2232  The Topology in use is shown below#Testing Telemetry Yang Paths on-boxIn this section, we intend to enable IPv6 on b2b interfaces on the two routers (r1 and r2) and stream IPv6 neighbor information to an onbox utility to verify the data.We will construct a dial-in Telemetry collector/client wherein the client initiates a connection to the router and then subscribes to a pre-configured subscription on the router.Set up IPv6 NeighborsTo start off, let’s enable IPv6 and configure IPv6 addresses on the b2b interfaces of r1 and r2.Configure IPv6 on router r1Connect to router r1#Username# adminPassword# adminSSH port# 2221IP# 10.10.20.170Laptop-terminal#$ ssh -p 2221 admin@10.10.20.170--------------------------------------------------------------------------  Router 1 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#Apply the following configuration on router r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#conf tMon Sep  3 09#00#33.672 UTCRP/0/RP0/CPU0#r1(config)#interface GigabitEthernet 0/0/0/0RP/0/RP0/CPU0#r1(config-if)#ipv6 enableRP/0/RP0/CPU0#r1(config-if)#ipv6 address 1010#1010##10/64RP/0/RP0/CPU0#r1(config-if)#no shutRP/0/RP0/CPU0#r1(config-if)#      RP/0/RP0/CPU0#r1(config-if)#RP/0/RP0/CPU0#r1(config-if)#exitRP/0/RP0/CPU0#r1(config)#RP/0/RP0/CPU0#r1(config)#interface GigabitEthernet 0/0/0/1RP/0/RP0/CPU0#r1(config-if)#ipv6 enable                      RP/0/RP0/CPU0#r1(config-if)#ipv6 address 2020#2020##10/64    RP/0/RP0/CPU0#r1(config-if)#no shutRP/0/RP0/CPU0#r1(config-if)#commitMon Sep  3 09#01#59.484 UTCRP/0/RP0/CPU0#r1(config-if)#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#show  configuration commit changes last 1Mon Sep  3 09#02#08.867 UTCBuilding configuration...!! IOS XR Configuration version = 6.4.1interface GigabitEthernet0/0/0/0 ipv6 address 1010#1010##10/64 ipv6 enable no shutdown!interface GigabitEthernet0/0/0/1 ipv6 address 2020#2020##10/64 ipv6 enable no shutdown!endRP/0/RP0/CPU0#r1#Configure IPv6 on router r2Similarly, connect to router r2#Username# adminPassword# adminSSH port# 2231IP# 10.10.20.170Laptop-terminal#$ ssh -p 2231 admin@10.10.20.170--------------------------------------------------------------------------  Router 2 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password#RP/0/RP0/CPU0#r2#RP/0/RP0/CPU0#r2#Apply the following configuration to router r2#RP/0/RP0/CPU0#r2#RP/0/RP0/CPU0#r2#conf tMon Sep  3 09#04#32.472 UTCRP/0/RP0/CPU0#r2(config)#interface GigabitEthernet 0/0/0/0RP/0/RP0/CPU0#r2(config-if)#ipv6 enableRP/0/RP0/CPU0#r2(config-if)#ipv6 address 1010#1010##20/64RP/0/RP0/CPU0#r2(config-if)#no shutRP/0/RP0/CPU0#r2(config-if)#exitRP/0/RP0/CPU0#r2(config)#interface GigabitEthernet 0/0/0/1RP/0/RP0/CPU0#r2(config-if)#ipv6 enableRP/0/RP0/CPU0#r2(config-if)#ipv6 address 2020#2020##20/64RP/0/RP0/CPU0#r2(config-if)#no shutRP/0/RP0/CPU0#r2(config-if)#commitMon Sep  3 09#05#37.371 UTCRP/0/RP0/CPU0#r2(config-if)#RP/0/RP0/CPU0#r2#RP/0/RP0/CPU0#r2#show  configuration commit changes last 1Mon Sep  3 09#05#51.846 UTCBuilding configuration...!! IOS XR Configuration version = 6.4.1interface GigabitEthernet0/0/0/0 ipv6 address 1010#1010##20/64 ipv6 enable no shutdown!interface GigabitEthernet0/0/0/1 ipv6 address 2020#2020##20/64 ipv6 enable no shutdown!endRP/0/RP0/CPU0#r2#Bring up IPv6 neighborsIPv6 Neighbor Discovery (ND) works much the same way as ARP. Neighbor discovery messages are not sent out until traffic flow for a particular IPv6 destination needs to traverse the IPv6 enabled interface.So if we dump the ipv6 neighbor information on the two routers, we don’t notice any reachable neighbors just yet.Router r1#RP/0/RP0/CPU0#r1#show  ipv6 neighborsMon Sep  3 09#13#17.796 UTCIPv6 Address                             Age  Link-layer Add State Interface            Location[Mcast adjacency]                           - 0000.0000.0000 REACH Gi0/0/0/0            0/0/CPU0       [Mcast adjacency]                           - 0000.0000.0000 REACH Gi0/0/0/1            0/0/CPU0       RP/0/RP0/CPU0#r1#Router r2#RP/0/RP0/CPU0#r2#show  ipv6 neighborsMon Sep  3 09#12#52.780 UTCIPv6 Address                             Age  Link-layer Add State Interface            Location[Mcast adjacency]                           - 0000.0000.0000 REACH Gi0/0/0/0            0/0/CPU0       [Mcast adjacency]                           - 0000.0000.0000 REACH Gi0/0/0/1            0/0/CPU0       RP/0/RP0/CPU0#r2#Ping the reachable NeighborsWe’ll use pings (icmpv6) as the trigger to generate IPv6 ND messages and establish neighbors dynamically#On router r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#ping 1010#1010##20Mon Sep  3 09#25#45.079 UTCType escape sequence to abort.Sending 5, 100-byte ICMP Echos to 1010#1010##20, timeout is 2 seconds#!!!!!Success rate is 100 percent (5/5), round-trip min/avg/max = 95/125/231 msRP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#ping 2020#2020##20Mon Sep  3 09#25#53.627 UTCType escape sequence to abort.Sending 5, 100-byte ICMP Echos to 2020#2020##20, timeout is 2 seconds#!!!!!Success rate is 100 percent (5/5), round-trip min/avg/max = 97/125/214 msRP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#Verify neighbors are upThe IPv6 neighbors should now be up!RP/0/RP0/CPU0#r1#show  ipv6 neighborsMon Sep  3 09#26#07.306 UTCIPv6 Address                             Age  Link-layer Add State Interface            Location1010#1010##20                            21   5254.0093.8ab0 REACH Gi0/0/0/0            0/0/CPU0       fe80##5054#ff#fe93#8ab0                  11   5254.0093.8ab0 REACH Gi0/0/0/0            0/0/CPU0       [Mcast adjacency]                           - 0000.0000.0000 REACH Gi0/0/0/0            0/0/CPU0       2020#2020##20                            13   5254.0093.8ab1 REACH Gi0/0/0/1            0/0/CPU0       fe80##5054#ff#fe93#8ab1                  2    5254.0093.8ab1 REACH Gi0/0/0/1            0/0/CPU0       [Mcast adjacency]                           - 0000.0000.0000 REACH Gi0/0/0/1            0/0/CPU0       RP/0/RP0/CPU0#r1#Configure Telemetry to Stream IPv6 neighbor informationThe IPv6 neighbors displayed using show ipv6 neighbors can be streamed using the IPv6-ND oper YANG model in IOS-XR. The Yang models for IOS-XR per release can be found on Github here# &lt;https#//github.com/YangModels/yang/tree/master/vendor/cisco/xr&gt;  In this lab we're working with IOS-XR release `6.4.1`#  RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#show  versionMon Sep  3 09#46#31.320 UTCCisco IOS XR Software, Version 6.4.1Copyright (c) 2013-2017 by Cisco Systems, Inc.Build Information# Built By     # nkhai Built On     # Wed Mar 28 19#20#20 PDT 2018 Build Host   # iox-lnx-090 Workspace    # /auto/srcarchive14/prod/6.4.1/xrv9k/ws Version      # 6.4.1 Location     # /opt/cisco/XR/packages/cisco IOS-XRv 9000 () processorSystem uptime is 2 hours, 28 minutesRP/0/RP0/CPU0#r1#  The required Yang models for this release are thus available here#&lt;https#//github.com/YangModels/yang/tree/master/vendor/cisco/xr/641&gt;  Figure out the Yang Model/Path to useThe Yang model we’re interested in is Cisco-IOS-XR-ipv6-nd-oper.yang, located here#  https#//github.com/YangModels/yang/blob/master/vendor/cisco/xr/641/Cisco-IOS-XR-ipv6-nd-oper.yangThe easiest way to understand the information available within the Yang model is to display the YANG model in a tree format using a tool called pyang.For this purpose, connect to the devbox#Username# adminPassword# adminSSH port# 2211IP# 10.10.20.170Laptop-terminal#$ ssh -p 2211 admin@10.10.20.170admin@10.10.20.170's password#Last login# Mon Sep  3 01#28#30 2018 from 192.168.122.1admin@devbox#~$admin@devbox#~$Clone the Yang git repo#admin@devbox#~$ git clone https#//github.com/YangModels/yangCloning into 'yang'...remote# Counting objects# 21847, done.remote# Compressing objects# 100% (218/218), done.remote# Total 21847 (delta 512), reused 709 (delta 505), pack-reused 21124Receiving objects# 100% (21847/21847), 42.52 MiB | 13.17 MiB/s, done.Resolving deltas# 100% (16807/16807), done.Checking connectivity... done.Checking out files# 100% (20153/20153), done.admin@devbox#~$admin@devbox#~$admin@devbox#~$ cd yang/vendor/cisco/xr/641/admin@devbox#641$ pwd/home/admin/yang/vendor/cisco/xr/641admin@devbox#641$Dump the Cisco-IOS-XR-ipv6-nd-oper.yang model in a tree format#admin@devbox#641$ pyang -f tree Cisco-IOS-XR-ipv6-nd-oper.yangmodule# Cisco-IOS-XR-ipv6-nd-oper   +--ro ipv6-node-discovery      +--ro nodes         +--ro node* [node-name]            +--ro neighbor-interfaces            |  +--ro neighbor-interface* [interface-name]            |     +--ro host-addresses            |     |  +--ro host-address* [host-address]            |     |     +--ro host-address              inet#ipv6-address-no-zone            |     |     +--ro last-reached-time            |     |     |  +--ro seconds?   uint32            |     |     +--ro reachability-state?       Ipv6-nd-sh-state            |     |     +--ro link-layer-address?       yang#mac-address            |     |     +--ro encapsulation?            Ipv6-nd-media-encap            |     |     +--ro selected-encapsulation?   Ipv6-nd-media-encap            |     |     +--ro origin-encapsulation?     Ipv6-nd-neighbor-origin            |     |     +--ro interface-name?           string            |     |     +--ro location?                 xr#Node-id            |     |     +--ro is-router?                boolean            |     |     +--ro serg-flags?               uint32            |     |     +--ro vrfid?                    uint32            |     +--ro interface-name    xr#Interface-name            +--ro neighbor-summary            |  +--ro multicast            |  |  +--ro incomplete-entries?          uint32            |  |  +--ro reachable-entries?           uint32            |  |  +--ro stale-entries?               uint32            |  |  +--ro delayed-entries?             uint32            |  |  +--ro probe-entries?               uint32            |  |  +--ro deleted-entries?             uint32            |  |  +--ro subtotal-neighbor-entries?   uint32            |  +--ro static            |  |  +--ro incomplete-entries?          uint32            |  |  +--ro reachable-entries?           uint32            |  |  +--ro stale-entries?               uint32            |  |  +--ro delayed-entries?             uint32            |  |  +--ro probe-entries?               uint32            |  |  +--ro deleted-entries?             uint32            |  |  +--ro subtotal-neighbor-entries?   uint32            |  +--ro dynamic            |  |  +--ro incomplete-entries?          uint32            |  |  +--ro reachable-entries?           uint32            |  |  +--ro stale-entries?               uint32            |  |  +--ro delayed-entries?             uint32            |  |  +--ro probe-entries?               uint32            |  |  +--ro deleted-entries?             uint32            |  |  +--ro subtotal-neighbor-entries?   uint32            |  +--ro total-neighbor-entries?   uint32            +--ro bundle-nodes            |  +--ro bundle-node* [node-name]            |     +--ro node-name                   xr#Node-id            |     +--ro age            |     |  +--ro seconds?   uint32            |     +--ro group-id?                   uint32            |     +--ro process-name?               string            |     +--ro sent-sequence-number?       uint32            |     +--ro received-sequence-number?   uint32            |     +--ro state?                      Ipv6-nd-bndl-state            |     +--ro state-changes?              uint32            |     +--ro sent-packets?               uint32            |     +--ro received-packets?           uint32            +--ro bundle-interfaces            |  +--ro bundle-interface* [interface-name]            |     +--ro interface-name           xr#Interface-name            |     +--ro nd-parameters            |     |  +--ro is-dad-enabled?               boolean            |     |  +--ro dad-attempts?                 uint32            |     |  +--ro is-icm-pv6-redirect?          boolean            |     |  +--ro is-dhcp-managed?              boolean            |     |  +--ro is-route-address-managed?     boolean            |     |  +--ro is-suppressed?                boolean            |     |  +--ro send-unicast-ra?              boolean            |     |  +--ro nd-retransmit-interval?       uint32            |     |  +--ro nd-min-transmit-interval?     uint32            |     |  +--ro nd-max-transmit-interval?     uint32            |     |  +--ro nd-advertisement-lifetime?    uint32            |     |  +--ro nd-reachable-time?            uint32            |     |  +--ro nd-cache-limit?               uint32            |     |  +--ro complete-protocol-count?      uint32            |     |  +--ro complete-glean-count?         uint32            |     |  +--ro incomplete-protocol-count?    uint32            |     |  +--ro incomplete-glean-count?       uint32            |     |  +--ro dropped-protocol-req-count?   uint32            |     |  +--ro dropped-glean-req-count?      uint32            |     +--ro local-address            |     |  +--ro ipv6-address?     inet#ipv6-address            |     |  +--ro valid-lifetime?   uint32            |     |  +--ro pref-lifetime?    uint32            |     +--ro parent-interface-name?   xr#Interface-name            |     +--ro iftype?                  uint32            |     +--ro mtu?                     uint32            |     +--ro etype?                   uint32            |     +--ro vlan-tag?                uint16            |     +--ro mac-addr-size?           uint32            |     +--ro mac-addr?                yang#mac-address            |     +--ro is-interface-enabled?    boolean            |     +--ro is-ipv6-enabled?         boolean            |     +--ro is-mpls-enabled?         boolean            |     +--ro member-link*             uint32            |     +--ro global-address*            |     |  +--ro ipv6-address?     inet#ipv6-address            |     |  +--ro valid-lifetime?   uint32            |     |  +--ro pref-lifetime?    uint32            |     +--ro member-node*            |        +--ro node-name?     xr#Node-id            |        +--ro total-links?   uint32            +--ro interfaces            |  +--ro interface* [interface-name]            |     +--ro interface-name                xr#Interface-name            |     +--ro is-dad-enabled?               boolean            |     +--ro dad-attempts?                 uint32            |     +--ro is-icm-pv6-redirect?          boolean            |     +--ro is-dhcp-managed?              boolean            |     +--ro is-route-address-managed?     boolean            |     +--ro is-suppressed?                boolean            |     +--ro send-unicast-ra?              boolean            |     +--ro nd-retransmit-interval?       uint32            |     +--ro nd-min-transmit-interval?     uint32            |     +--ro nd-max-transmit-interval?     uint32            |     +--ro nd-advertisement-lifetime?    uint32            |     +--ro nd-reachable-time?            uint32            |     +--ro nd-cache-limit?               uint32            |     +--ro complete-protocol-count?      uint32            |     +--ro complete-glean-count?         uint32            |     +--ro incomplete-protocol-count?    uint32            |     +--ro incomplete-glean-count?       uint32            |     +--ro dropped-protocol-req-count?   uint32            |     +--ro dropped-glean-req-count?      uint32            +--ro nd-virtual-routers            |  +--ro nd-virtual-router* [interface-name]            |     +--ro interface-name        xr#Interface-name            |     +--ro local-address            |     |  +--ro ipv6-address?     inet#ipv6-address            |     |  +--ro valid-lifetime?   uint32            |     |  +--ro pref-lifetime?    uint32            |     +--ro link-layer-address?   yang#mac-address            |     +--ro context?              uint32            |     +--ro state?                Ipv6-nd-sh-vr-state            |     +--ro flags?                Ipv6-nd-sh-vr-flags            |     +--ro vr-gl-addr-ct?        uint32            |     +--ro vr-global-address*            |        +--ro ipv6-address?     inet#ipv6-address            |        +--ro valid-lifetime?   uint32            |        +--ro pref-lifetime?    uint32            +--ro slaac-interfaces            |  +--ro slaac-interface* [interface-name]            |     +--ro router-advert-detail            |     |  +--ro idb?   xr#Interface-name            |     |  +--ro ra*            |     |     +--ro elapsed-ra-time            |     |     |  +--ro seconds?   uint32            |     |     +--ro reachable-time            |     |     |  +--ro seconds?   uint32            |     |     +--ro retrans-time            |     |     |  +--ro seconds?   uint32            |     |     +--ro address?           inet#ipv6-address            |     |     +--ro hops?              uint32            |     |     +--ro flags?             uint32            |     |     +--ro life-time?         uint32            |     |     +--ro mtu?               uint32            |     |     +--ro err-msg?           boolean            |     |     +--ro vrf-id?            uint32            |     |     +--ro u6-tbl-id?         uint32            |     |     +--ro rib-protoid?       uint16            |     |     +--ro default-router?    boolean            |     |     +--ro reachability?      uint32            |     |     +--ro prefix-q*            |     |        +--ro prefix-address?        inet#ipv6-address            |     |        +--ro eui64?                 inet#ipv6-address            |     |        +--ro valid-life-time?       uint32            |     |        +--ro preferred-life-time?   uint32            |     |        +--ro prefix-len?            uint32            |     |        +--ro flags?                 uint32            |     |        +--ro pfx-flags?             uint32            |     +--ro interface-name          xr#Interface-name            +--ro node-name              xr#Node-idadmin@devbox#641$From the above dump, it becomes fairly clear that we intend to extract the following set of nodes from the model to match the information in the show ipv6 neighbors output#module# Cisco-IOS-XR-ipv6-nd-oper   +--ro ipv6-node-discovery      +--ro nodes         +--ro node* [node-name]            +--ro neighbor-interfaces            |  +--ro neighbor-interface* [interface-name]            |     +--ro host-addresses            |     |  +--ro host-address* [host-address]            |     |     +--ro host-address              inet#ipv6-address-no-zone            |     |     +--ro last-reached-time            |     |     |  +--ro seconds?   uint32            |     |     +--ro reachability-state?       Ipv6-nd-sh-state            |     |     +--ro link-layer-address?       yang#mac-address            |     |     +--ro encapsulation?            Ipv6-nd-media-encap            |     |     +--ro selected-encapsulation?   Ipv6-nd-media-encap            |     |     +--ro origin-encapsulation?     Ipv6-nd-neighbor-origin            |     |     +--ro interface-name?           string            |     |     +--ro location?                 xr#Node-id            |     |     +--ro is-router?                boolean            |     |     +--ro serg-flags?               uint32            |     |     +--ro vrfid?                    uint32Setting up the Telemetry configurationThe container path that we need to set up as part of the Telemetry configuration is highlighted above.On the router, this becomes the following sensor-path#!telemetry model-driven sensor-group IPV6Neighbor  sensor-path Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address !Creating a subscription out of this path to stream the data every 15 seconds, we get the following additional configuration#telemetry model-driven sensor-group IPV6Neighbor  sensor-path Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address ! subscription IPV6  sensor-group-id IPV6Neighbor sample-interval 15000 !!If we wait a few seconds, we will notice that this sensor-path gets Resolved indicating that the router is now ready to send Telemetry data to an external collector.RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#show  telemetry model-driven subscription IPV6 internalMon Sep  3 10#50#20.451 UTCSubscription#  IPV6-------------  State#       NA  Sensor groups#  Id# IPV6Neighbor    Sample Interval#      15000 ms    Sensor Path#          Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address    Sensor Path State#    Resolved  Collection Groups#  ------------------  No active collection groupsRP/0/RP0/CPU0#r1#Testing the Sensor pathBefore we proceed, let’s actually test the sensor path to make sure we’re getting the relevant data. Starting with release 6.3.1, this can be done on the router itself  by using the following CLI command#run mdt_exec -s &lt;your_sensor_path&gt; -c &lt;cadence&gt;Trying this out on router r1 for the sensor_path=Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address and cadence=2000 (2 seconds), we get#Just press `Enter` to terminate.RP/0/RP0/CPU0#r1#run mdt_exec -s Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address -c 2000Mon Sep  3 17#54#56.475 UTCEnter any key to exit... Sub_id 200000001, flag 0, len 0 Sub_id 200000001, flag 4, len 3072--------{~node_id_str~#~r1~,~subscription_id_str~#~app_TEST_200000001~,~encoding_path~#~Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address~,~collection_id~#4,~collection_start_time~#1535997296669,~msg_timestamp~#1535997296675,~data_json~#[{~timestamp~#1535997296674,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~1010#1010##20~},~content~#{~last-reached-time~#{~seconds~#38},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab0~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997296674,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~fe80##5054#ff#fe93#8ab0~},~content~#{~last-reached-time~#{~seconds~#179},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab0~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997296675,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~ffff#ffff#ffff#ffff#ffff#ffff#ffff#ffff~},~content~#{~last-reached-time~#{~seconds~#0},~reachability-state~#~reachable~,~link-layer-address~#~0000.0000.0000~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~static~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#false,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997296676,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~2020#2020##20~},~content~#{~last-reached-time~#{~seconds~#170},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab1~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997296676,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~fe80##5054#ff#fe93#8ab1~},~content~#{~last-reached-time~#{~seconds~#165},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab1~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997296676,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~ffff#ffff#ffff#ffff#ffff#ffff#ffff#ffff~},~content~#{~last-reached-time~#{~seconds~#0},~reachability-state~#~reachable~,~link-layer-address~#~0000.0000.0000~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~static~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#false,~serg-flags~#255,~vrfid~#1610612736}}],~collection_end_time~#1535997296677}-------- Sub_id 200000001, flag 4, len 3068--------{~node_id_str~#~r1~,~subscription_id_str~#~app_TEST_200000001~,~encoding_path~#~Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address~,~collection_id~#5,~collection_start_time~#1535997298677,~msg_timestamp~#1535997298684,~data_json~#[{~timestamp~#1535997298683,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~1010#1010##20~},~content~#{~last-reached-time~#{~seconds~#40},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab0~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997298683,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~fe80##5054#ff#fe93#8ab0~},~content~#{~last-reached-time~#{~seconds~#181},~reachability-state~#~delay~,~link-layer-address~#~5254.0093.8ab0~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997298683,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~ffff#ffff#ffff#ffff#ffff#ffff#ffff#ffff~},~content~#{~last-reached-time~#{~seconds~#0},~reachability-state~#~reachable~,~link-layer-address~#~0000.0000.0000~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~static~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#false,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997298685,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~2020#2020##20~},~content~#{~last-reached-time~#{~seconds~#172},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab1~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997298685,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~fe80##5054#ff#fe93#8ab1~},~content~#{~last-reached-time~#{~seconds~#167},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab1~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997298685,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~ffff#ffff#ffff#ffff#ffff#ffff#ffff#ffff~},~content~#{~last-reached-time~#{~seconds~#0},~reachability-state~#~reachable~,~link-layer-address~#~0000.0000.0000~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~static~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#false,~serg-flags~#255,~vrfid~#1610612736}}],~collection_end_time~#1535997298686}--------RP/0/RP0/CPU0#r1#Let’s just structure the data above a little better to see what we’rereceiving. Drop into router r1’s  python shell and use the json module to “pretty” print it.RP/0/RP0/CPU0#r1#bashMon Sep  3 17#58#00.770 UTC[r1#~]$[r1#~]$ pythonPython 2.7.3 (default, Dec 12 2017, 08#22#03)[GCC 4.9.1] on linux2Type ~help~, ~copyright~, ~credits~ or ~license~ for more information.&gt;&gt;&gt; import json&gt;&gt;&gt;&gt;&gt;&gt; data=~~~{~node_id_str~#~r1~,~subscription_id_str~#~app_TEST_200000001~,~encoding_path~#~Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address~,~collection_id~#6,~collection_start_time~#1535997300686,~msg_timestamp~#1535997300703,~data_json~#[{~timestamp~#1535997300701,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~1010#1010##20~},~content~#{~last-reached-time~#{~seconds~#42},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab0~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997300701,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~fe80##5054#ff#fe93#8ab0~},~content~#{~last-reached-time~#{~seconds~#183},~reachability-state~#~delay~,~link-layer-address~#~5254.0093.8ab0~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997300701,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/0~,~host-address~#~ffff#ffff#ffff#ffff#ffff#ffff#ffff#ffff~},~content~#{~last-reached-time~#{~seconds~#0},~reachability-state~#~reachable~,~link-layer-address~#~0000.0000.0000~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~static~,~interface-name~#~Gi0/0/0/0~,~location~#~0/0/CPU0~,~is-router~#false,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997300707,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~2020#2020##20~},~content~#{~last-reached-time~#{~seconds~#174},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab1~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997300707,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~fe80##5054#ff#fe93#8ab1~},~content~#{~last-reached-time~#{~seconds~#169},~reachability-state~#~reachable~,~link-layer-address~#~5254.0093.8ab1~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~dynamic~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#true,~serg-flags~#255,~vrfid~#1610612736}},{~timestamp~#1535997300707,~keys~#{~node-name~#~0/0/CPU0~,~interface-name~#~GigabitEthernet0/0/0/1~,~host-address~#~ffff#ffff#ffff#ffff#ffff#ffff#ffff#ffff~},~content~#{~last-reached-time~#{~seconds~#0},~reachability-state~#~reachable~,~link-layer-address~#~0000.0000.0000~,~encapsulation~#~arpa~,~selected-encapsulation~#~arpa~,~origin-encapsulation~#~static~,~interface-name~#~Gi0/0/0/1~,~location~#~0/0/CPU0~,~is-router~#false,~serg-flags~#255,~vrfid~#1610612736}}],~collection_end_time~#1535997300709}~~~&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; print json.dumps(json.loads(data), indent=4){   ~encoding_path~# ~Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address~,   ~subscription_id_str~# ~app_TEST_200000001~,   ~collection_start_time~# 1535997300686,   ~msg_timestamp~# 1535997300703,   ~collection_end_time~# 1535997300709,   ~node_id_str~# ~r1~,   ~data_json~# [       {           ~keys~# {               ~node-name~# ~0/0/CPU0~,               ~interface-name~# ~GigabitEthernet0/0/0/0~,               ~host-address~# ~1010#1010##20~           },           ~timestamp~# 1535997300701,           ~content~# {               ~vrfid~# 1610612736,               ~interface-name~# ~Gi0/0/0/0~,               ~last-reached-time~# {                   ~seconds~# 42               },               ~link-layer-address~# ~5254.0093.8ab0~,               ~selected-encapsulation~# ~arpa~,               ~is-router~# true,               ~serg-flags~# 255,               ~reachability-state~# ~reachable~,               ~location~# ~0/0/CPU0~,               ~encapsulation~# ~arpa~,               ~origin-encapsulation~# ~dynamic~           }       },       {           ~keys~# {               ~node-name~# ~0/0/CPU0~,               ~interface-name~# ~GigabitEthernet0/0/0/0~,               ~host-address~# ~fe80##5054#ff#fe93#8ab0~           },           ~timestamp~# 1535997300701,           ~content~# {               ~vrfid~# 1610612736,               ~interface-name~# ~Gi0/0/0/0~,               ~last-reached-time~# {                   ~seconds~# 183               },               ~link-layer-address~# ~5254.0093.8ab0~,               ~selected-encapsulation~# ~arpa~,               ~is-router~# true,               ~serg-flags~# 255,               ~reachability-state~# ~delay~,               ~location~# ~0/0/CPU0~,               ~encapsulation~# ~arpa~,               ~origin-encapsulation~# ~dynamic~           }       },       {           ~keys~# {               ~node-name~# ~0/0/CPU0~,               ~interface-name~# ~GigabitEthernet0/0/0/0~,               ~host-address~# ~ffff#ffff#ffff#ffff#ffff#ffff#ffff#ffff~           },           ~timestamp~# 1535997300701,           ~content~# {               ~vrfid~# 1610612736,               ~interface-name~# ~Gi0/0/0/0~,               ~last-reached-time~# {                   ~seconds~# 0               },               ~link-layer-address~# ~0000.0000.0000~,               ~selected-encapsulation~# ~arpa~,               ~is-router~# false,               ~serg-flags~# 255,               ~reachability-state~# ~reachable~,               ~location~# ~0/0/CPU0~,               ~encapsulation~# ~arpa~,               ~origin-encapsulation~# ~static~           }       },       {           ~keys~# {               ~node-name~# ~0/0/CPU0~,               ~interface-name~# ~GigabitEthernet0/0/0/1~,               ~host-address~# ~2020#2020##20~           },           ~timestamp~# 1535997300707,           ~content~# {               ~vrfid~# 1610612736,               ~interface-name~# ~Gi0/0/0/1~,               ~last-reached-time~# {                   ~seconds~# 174               },               ~link-layer-address~# ~5254.0093.8ab1~,               ~selected-encapsulation~# ~arpa~,               ~is-router~# true,               ~serg-flags~# 255,               ~reachability-state~# ~reachable~,               ~location~# ~0/0/CPU0~,               ~encapsulation~# ~arpa~,               ~origin-encapsulation~# ~dynamic~           }       },       {           ~keys~# {               ~node-name~# ~0/0/CPU0~,               ~interface-name~# ~GigabitEthernet0/0/0/1~,               ~host-address~# ~fe80##5054#ff#fe93#8ab1~           },           ~timestamp~# 1535997300707,           ~content~# {               ~vrfid~# 1610612736,               ~interface-name~# ~Gi0/0/0/1~,               ~last-reached-time~# {                   ~seconds~# 169               },               ~link-layer-address~# ~5254.0093.8ab1~,               ~selected-encapsulation~# ~arpa~,               ~is-router~# true,               ~serg-flags~# 255,               ~reachability-state~# ~reachable~,               ~location~# ~0/0/CPU0~,               ~encapsulation~# ~arpa~,               ~origin-encapsulation~# ~dynamic~           }       },       {           ~keys~# {               ~node-name~# ~0/0/CPU0~,               ~interface-name~# ~GigabitEthernet0/0/0/1~,               ~host-address~# ~ffff#ffff#ffff#ffff#ffff#ffff#ffff#ffff~           },           ~timestamp~# 1535997300707,           ~content~# {               ~vrfid~# 1610612736,               ~interface-name~# ~Gi0/0/0/1~,               ~last-reached-time~# {                   ~seconds~# 0               },               ~link-layer-address~# ~0000.0000.0000~,               ~selected-encapsulation~# ~arpa~,               ~is-router~# false,               ~serg-flags~# 255,               ~reachability-state~# ~reachable~,               ~location~# ~0/0/CPU0~,               ~encapsulation~# ~arpa~,               ~origin-encapsulation~# ~static~           }       }   ],   ~collection_id~# 6}&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exit()[r1#~]$[r1#~]$ exitlogoutRP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#Perfect! We're receiving all the fields we need as per the original show command. You're now ready to start building your own Telemetry collector.Building your own clientsWe learnt in the earlier sections that IOS-XR supports streaming Telemetry data over raw TCP (dial-out) and gRPC (dial-in and dial-out). The structure of the streamable data is derived from Oper YANG models.Now, these Oper Yang-models can also be mapped to equivalent protobuf models, represented in .proto files.This is especially useful when we need to write a Telemetry client code from scratch.By exposing these protobuf-based capabilities over a gRPC connection, it enables a user to utilize gRPC’s intrinsic architecture to generate bindings(code/libraries) in a language of choice (python, c++, golang etc.).To view the .proto files corresponding to the Oper Yang models in XR, clone the following git repo on the devbox and peek into the proto_archive/ directory#  https#//github.com/cisco/bigmuddy-network-telemetry-protoThis represents all the available Oper Yang models arranged as folders containing the .proto files.We can generate bindings in the language of choice (python, c++, golang etc.) using these .proto files and leverage the bindings to subscribe to the router’s Telemetry stream as well as decode the data received. We will delve into these scenarios and write our own Telemetry client/collector in subsequent labs in this module.Clean up!Finally, clean up the telemetry configuration from router r1 as we progress to the next stage of the lab#Remove existing telemetry configurations from r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#conf tTue Sep  4 08#01#03.269 UTCRP/0/RP0/CPU0#r1(config)#no telemetry model-drivenRP/0/RP0/CPU0#r1(config)#commitTue Sep  4 08#01#06.422 UTCRP/0/RP0/CPU0#r1(config)#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#",
      "url": "/wkinstructions/2019-02-01-step-4-quick-look-at-model-driven-telemetry-on-ios-xr/",
      "author": "Akshat Sharma",
      "tags": "iosxr, cisco, telemetry, lab"
    }
    
    ,
  
  
  
    "wkinstructions-2019-02-01-step-5-playing-iosxr-yang-models": {
      "title": "Step 5: Playing with IOS-XR YANG Models",
      "content": "     On This Page  To Know More  Ansible netconf_config module          Install ncclient      Execute the Ansible playbook to configure BGP      Check the BGP configuration on the routers        YDK          YDK python script to configure Model-Driven Telemetry      Execute the YDK script#      Check the Telemetry configuration on router r1      Verify that the Telemetry sensor-paths are resolved        Writing your own Python Telemetry client          Install dependencies for the gRPC telemetry client      Clone the Telemetry gRPC collectors git repo      Build the Bindings for Model Driven Telemetry gRPC clients      Running a simple python Telemetry client        To Know MoreThere are several tools in the industry that allow you to play around with YANG models on IOS-XR and other Network OS stacks.In this lab we will look at a few of them#      The Ansible netconf_config module to configure a BGP session on the routers. https#//docs.ansible.com/ansible/2.4/netconf_config_module.html    Yang Development Kit (YDK) to configure Telemetry and interfaces on the routers# http#//ydk.io  Your own python Telemetry client which we will use to extract python data coming from YANG paths set up by YDK#https#//learninglabs.cisco.com/tracks/iosxr-programmability/iosxr-streaming-telemetry/03-iosxr-02-telemetry-python/step/1. Also, a lot more on Telemetry here# https#//xrdocs.io/telemetry/  Connect to your Pod first! Make sure your Anyconnect VPN connection to the Pod assigned to you is active.  If you haven’t connected yet, check out the instructions to do so here#https#//sevt-sp.github.io/xr-programmability-lab/connect-to-pods/  Once you’re connected, use the following instructions to connect to the individual nodes.The instructions in the workshop will simply refer to the Name of the box to connect withoutrepeating the connection details and credentials. So refer back to this list when you need it.  The 3 nodes in the topology are#  Development Linux System (DevBox)   IP Address# 10.10.20.170 Username/Password# [admin/admin] SSH Port# 2211    IOS-XRv9000 R1# (Router r1)  IP Address# 10.10.20.170  Username/Password# [admin/admin]   Management IP# 10.10.20.170  XR SSH Port# 2221    NETCONF Port# 8321   gRPC Port# 57021  XR-Bash SSH Port# 2222        IOS-XRv9000 R2#  (Router r2)  IP Address# 10.10.20.170   Username/Password# [admin/admin]   Management IP# 10.10.20.170   XR SSH Port# 2231    NETCONF Port# 8331   gRPC Port# 57031    XR-Bash SSH Port# 2232  The Topology in use is shown below#Ansible netconf_config moduleHop into the devbox and browse to the ansible directory#AKSHSHAR-M-33WP#~ akshshar$ ssh -p 2211 admin@10.10.20.170admin@10.10.20.170's password# Last login# Tue Jan 29 18#35#38 2019 from 192.168.122.1admin@devbox#~$ admin@devbox#~$ admin@devbox#~$ cd xr-programmability-lab-code/admin@devbox#xr-programmability-lab-code$ lsansible  README.md  ztp_hooksadmin@devbox#xr-programmability-lab-code$ cd ansible/admin@devbox#ansible$ lsansible_hosts  configure_bgp_netconf.yml  docker_bringup.yml  execute_python_ztp.yml  openr  set_ipv6_route.sh  xmladmin@devbox#ansible$ We will be using the playbook# configure_bgp_netconf.yml which uses the netconf_config module which in turn utilizes the XML encoded data to configure BGP on routers r1 and r2#The playbook is dumped below#admin@devbox#ansible$ admin@devbox#ansible$ cat configure_bgp_netconf.yml ---- hosts# routers_shell  connection# local  gather_facts# no  tasks#  - name# Configure BGP on the router    netconf_config#      host# ~~      port# ~~      username# ~~      password# ~~      hostkey_verify# no      xml# ~~admin@devbox#ansible$ admin@devbox#ansible$ The xml file used by the above playbook to configure BGP on router r1 is shown below. This XML data utilizes the IOS-XR BGP Config YANG model#  Cisco-IOS-XR-ipv4-bgp-cfg.admin@devbox#ansible$ cat xml/r1-bgp.xml &lt;config&gt;  &lt;bgp xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-ipv4-bgp-cfg~&gt;   &lt;instance&gt;    &lt;instance-name&gt;default&lt;/instance-name&gt;    &lt;instance-as&gt;     &lt;as&gt;0&lt;/as&gt;     &lt;four-byte-as&gt;      &lt;as&gt;65000&lt;/as&gt;      &lt;bgp-running&gt;&lt;/bgp-running&gt;      &lt;default-vrf&gt;       &lt;global&gt;        &lt;router-id&gt;50.1.1.1&lt;/router-id&gt;        &lt;global-afs&gt;         &lt;global-af&gt;          &lt;af-name&gt;ipv4-unicast&lt;/af-name&gt;          &lt;enable&gt;&lt;/enable&gt;         &lt;/global-af&gt;        &lt;/global-afs&gt;       &lt;/global&gt;       &lt;bgp-entity&gt;        &lt;neighbors&gt;         &lt;neighbor&gt;          &lt;neighbor-address&gt;60.1.1.1&lt;/neighbor-address&gt;          &lt;remote-as&gt;           &lt;as-xx&gt;0&lt;/as-xx&gt;           &lt;as-yy&gt;65000&lt;/as-yy&gt;          &lt;/remote-as&gt;          &lt;update-source-interface&gt;Loopback0&lt;/update-source-interface&gt;          &lt;neighbor-afs&gt;           &lt;neighbor-af&gt;            &lt;af-name&gt;ipv4-unicast&lt;/af-name&gt;            &lt;activate&gt;&lt;/activate&gt;           &lt;/neighbor-af&gt;          &lt;/neighbor-afs&gt;         &lt;/neighbor&gt;        &lt;/neighbors&gt;       &lt;/bgp-entity&gt;      &lt;/default-vrf&gt;     &lt;/four-byte-as&gt;    &lt;/instance-as&gt;   &lt;/instance&gt;      &lt;/bgp&gt;    &lt;/config&gt;admin@devbox#ansible$ Similarly, the XML file for router r2#admin@devbox#ansible$ admin@devbox#ansible$ admin@devbox#ansible$ cat xml/r2-bgp.xml &lt;config&gt;  &lt;bgp xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-ipv4-bgp-cfg~&gt;    &lt;instance&gt;     &lt;instance-name&gt;default&lt;/instance-name&gt;     &lt;instance-as&gt;      &lt;as&gt;0&lt;/as&gt;      &lt;four-byte-as&gt;       &lt;as&gt;65000&lt;/as&gt;       &lt;bgp-running&gt;&lt;/bgp-running&gt;       &lt;default-vrf&gt;        &lt;global&gt;         &lt;router-id&gt;60.1.1.1&lt;/router-id&gt;         &lt;global-afs&gt;          &lt;global-af&gt;           &lt;af-name&gt;ipv4-unicast&lt;/af-name&gt;           &lt;enable&gt;&lt;/enable&gt;          &lt;/global-af&gt;         &lt;/global-afs&gt;        &lt;/global&gt;        &lt;bgp-entity&gt;         &lt;neighbors&gt;          &lt;neighbor&gt;           &lt;neighbor-address&gt;50.1.1.1&lt;/neighbor-address&gt;           &lt;remote-as&gt;            &lt;as-xx&gt;0&lt;/as-xx&gt;            &lt;as-yy&gt;65000&lt;/as-yy&gt;           &lt;/remote-as&gt;           &lt;update-source-interface&gt;Loopback0&lt;/update-source-interface&gt;           &lt;neighbor-afs&gt;            &lt;neighbor-af&gt;             &lt;af-name&gt;ipv4-unicast&lt;/af-name&gt;             &lt;activate&gt;&lt;/activate&gt;            &lt;/neighbor-af&gt;           &lt;/neighbor-afs&gt;          &lt;/neighbor&gt;         &lt;/neighbors&gt;        &lt;/bgp-entity&gt;       &lt;/default-vrf&gt;      &lt;/four-byte-as&gt;     &lt;/instance-as&gt;    &lt;/instance&gt;   &lt;/bgp&gt;&lt;/config&gt;admin@devbox#ansible$ Install ncclientncclient is an open source library (https#//pypi.org/project/ncclient/) that can be used to connect to the netconf subsystem over SSH for multiple different vendor OSes (including IOS-XR).It then allows the user to pass in XML encoded YANG data to interact with the router OS and manipulate its provisioned state or extract operational data.The Ansible netconf_config module requires ncclient to be installed on the system. Let’s install ncclient first#admin@devbox#ansible$ sudo pip2 install ncclientThe directory '/home/admin/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/admin/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Collecting ncclient  Downloading https#//files.pythonhosted.org/packages/dc/95/acc44c2ff966743fedd1ad991ecf2498f40fd434883c67138b60a6373d49/ncclient-0.6.3.tar.gz (88kB)    100% |████████████████████████████████| 92kB 598kB/s Requirement already satisfied# setuptools&gt;0.6 in /usr/lib/python3/dist-packages (from ncclient) (20.7.0)Requirement already satisfied# paramiko&gt;=1.15.0 in /usr/local/lib/python3.5/dist-packages (from ncclient) (2.4.2)Collecting lxml&gt;=3.3.0 (from ncclient)  Downloading https#//files.pythonhosted.org/packages/f0/b6/6423a06e3fd191c5c9bea3cd636a175eb7b0b3e3c8d5c58c4e6bf3b43193/lxml-4.3.0-cp35-cp35m-manylinux1_x86_64.whl (5.6MB)    100% |████████████████████████████████| 5.6MB 7.5MB/s Collecting selectors2&gt;=2.0.1 (from ncclient)  Downloading https#//files.pythonhosted.org/packages/c9/89/8a07d6d6c78422c5151f68453e9741af4cd82bebcfa73923f73b3bdbef0d/selectors2-2.0.1-py2.py3-none-any.whlRequirement already satisfied# six in /usr/lib/python3/dist-packages (from ncclient) (1.10.0)Requirement already satisfied# pynacl&gt;=1.0.1 in /usr/local/lib/python3.5/dist-packages (from paramiko&gt;=1.15.0-&gt;ncclient) (1.3.0)Requirement already satisfied# cryptography&gt;=1.5 in /usr/local/lib/python3.5/dist-packages (from paramiko&gt;=1.15.0-&gt;ncclient) (2.5)Requirement already satisfied# pyasn1&gt;=0.1.7 in /usr/local/lib/python3.5/dist-packages (from paramiko&gt;=1.15.0-&gt;ncclient) (0.4.5)Requirement already satisfied# bcrypt&gt;=3.1.3 in /usr/local/lib/python3.5/dist-packages (from paramiko&gt;=1.15.0-&gt;ncclient) (3.1.6)Requirement already satisfied# cffi&gt;=1.4.1 in /usr/local/lib/python3.5/dist-packages (from pynacl&gt;=1.0.1-&gt;paramiko&gt;=1.15.0-&gt;ncclient) (1.11.5)Requirement already satisfied# asn1crypto&gt;=0.21.0 in /usr/local/lib/python3.5/dist-packages (from cryptography&gt;=1.5-&gt;paramiko&gt;=1.15.0-&gt;ncclient) (0.24.0)Requirement already satisfied# pycparser in /usr/local/lib/python3.5/dist-packages (from cffi&gt;=1.4.1-&gt;pynacl&gt;=1.0.1-&gt;paramiko&gt;=1.15.0-&gt;ncclient) (2.19)Installing collected packages# lxml, selectors2, ncclient  Running setup.py install for ncclient ... doneSuccessfully installed lxml-4.3.0 ncclient-0.6.3 selectors2-2.0.1You are using pip version 10.0.1, however version 19.0.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.admin@devbox#ansible$ In the end, you should have a relatively latest version of ncclient installed (version could differ based on when you run this lab)#admin@devbox#ansible$ pip2 list | grep ncclientncclient                0.6.3  admin@devbox#ansible$Execute the Ansible playbook to configure BGPWith ncclient installed, execute the Ansible playbook to configure BGP on the two routers#  IMPORTANT# Before you run the ansible playbook, make sure you set the &gt;ANSIBLE_HOST_KEY_CHECKING environment variable to false to allow Ansible to easily connect without being stalled by keychecking requirements for the two routers. This can also be set in the ansible_cfg file instead.  admin@devbox#ansible$ admin@devbox#ansible$ export ANSIBLE_HOST_KEY_CHECKING=False    {# .notice–danger} .admin@devbox#ansible$ ansible-playbook -i ansible_hosts configure_bgp_netconf.yml PLAY [routers_shell] ********************************************************************************************************************TASK [Configure BGP on the router] ******************************************************************************************************ok# [r1]ok# [r2]PLAY RECAP ******************************************************************************************************************************r1                         # ok=1    changed=0    unreachable=0    failed=0   r2                         # ok=1    changed=0    unreachable=0    failed=0   admin@devbox#ansible$ Check the BGP configuration on the routersHop over to router r1 and see that BGP has been configured#AKSHSHAR-M-33WP#~ akshshar$ ssh -p 2221 admin@10.10.20.170--------------------------------------------------------------------------  Router 1 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password# RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#show run router bgpWed Jan 30 04#32#27.173 UTCrouter bgp 65000 bgp router-id 50.1.1.1 address-family ipv4 unicast ! neighbor 60.1.1.1  remote-as 65000  update-source Loopback0  address-family ipv4 unicast  ! !!RP/0/RP0/CPU0#r1#Similarly, on router r2#RP/0/RP0/CPU0#r2#show run router bgpWed Jan 30 04#29#24.722 UTC% No such configuration item(s)RP/0/RP0/CPU0#r2#show run router bgpWed Jan 30 04#32#14.159 UTCrouter bgp 65000 bgp router-id 60.1.1.1 address-family ipv4 unicast ! neighbor 50.1.1.1  remote-as 65000  update-source Loopback0  address-family ipv4 unicast  ! !!RP/0/RP0/CPU0#r2#YDKTo know more about YDK, head over to http#//ydk.ioYDK python script to configure Model-Driven TelemetryYDK-py is already installed in the devbox for you.Jump into the ydk directory in the clone github repository#admin@devbox#~$ cd ~/xr-programmability-lab-code/admin@devbox#xr-programmability-lab-code$ cd ydk/admin@devbox#ydk$   Writing your own python script with YDK to interact with Yang models on IOS-XR and the other Vendor OSes is straightforward and you will find tons of resources in the git repository#https#//github.com/CiscoDevNet/ydk-py-samples with hundreds of examples across different models supported by IOS-XR.The YDK script used for this purpose is shown below#admin@devbox#ydk$ cat configure_telemetry_openconfig.py #!/usr/bin/env python## Copyright 2016 Cisco Systems, Inc.## Licensed under the Apache License, Version 2.0 (the ~License~);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at##     http#//www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an ~AS IS~ BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.#~~~Create configuration for model openconfig-telemetry.usage# configure_telemetry_openconfig.py [-h] [-v] devicepositional arguments#  device         NETCONF device (ssh#//user#password@host#port)optional arguments#  -h, --help     show this help message and exit  -v, --verbose  print debugging messages~~~from argparse import ArgumentParserfrom urlparse import urlparsefrom ydk.services import CRUDServicefrom ydk.providers import NetconfServiceProviderfrom ydk.models.openconfig import openconfig_telemetry \\    as oc_telemetryimport loggingdef config_telemetry_system(telemetry_system)#    ~~~Add config data to telemetry_system object.~~~    #sensor-group    sensor_group = telemetry_system.sensor_groups.SensorGroup()    sensor_group.sensor_group_id = ~BGPSession~    sensor_path = sensor_group.sensor_paths.SensorPath()    sensor_path.path = ~Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/sessions~    sensor_group.sensor_paths.sensor_path.append(sensor_path)    telemetry_system.sensor_groups.sensor_group.append(sensor_group)    sensor_path = sensor_group.sensor_paths.SensorPath()    sensor_path.path = ~Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/process-info~    sensor_group.sensor_paths.sensor_path.append(sensor_path)    telemetry_system.sensor_groups.sensor_group.append(sensor_group)    sensor_group = telemetry_system.sensor_groups.SensorGroup()    sensor_group.sensor_group_id = ~IPV6Neighbor~    sensor_path = sensor_group.sensor_paths.SensorPath()    sensor_path.path = ~Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address~    sensor_group.sensor_paths.sensor_path.append(sensor_path)    telemetry_system.sensor_groups.sensor_group.append(sensor_group)    #subscription    subscription = telemetry_system.subscriptions.persistent.Subscription()    subscription.subscription_id = 1    sensor_profile = subscription.sensor_profiles.SensorProfile()    sensor_profile.sensor_group = ~BGPSession~    sensor_profile.config.sensor_group = ~BGPSession~    sensor_profile.config.sample_interval = 15000    subscription.sensor_profiles.sensor_profile.append(sensor_profile)    telemetry_system.subscriptions.persistent.subscription.append(subscription)    subscription = telemetry_system.subscriptions.persistent.Subscription()    subscription.subscription_id = 2    sensor_profile = subscription.sensor_profiles.SensorProfile()    sensor_profile.sensor_group = ~IPV6Neighbor~    sensor_profile.config.sensor_group = ~IPV6Neighbor~    sensor_profile.config.sample_interval = 15000    subscription.sensor_profiles.sensor_profile.append(sensor_profile)    telemetry_system.subscriptions.persistent.subscription.append(subscription)if __name__ == ~__main__~#    ~~~Execute main program.~~~    parser = ArgumentParser()    parser.add_argument(~-v~, ~--verbose~, help=~print debugging messages~,                        action=~store_true~)    parser.add_argument(~device~,                        help=~NETCONF device (ssh#//user#password@host#port)~)    args = parser.parse_args()    device = urlparse(args.device)    # log debug messages if verbose argument specified    if args.verbose#        logger = logging.getLogger(~ydk~)        logger.setLevel(logging.INFO)        handler = logging.StreamHandler()        formatter = logging.Formatter((~%(asctime)s - %(name)s - ~                                      ~%(levelname)s - %(message)s~))        handler.setFormatter(formatter)        logger.addHandler(handler)    # create NETCONF provider    provider = NetconfServiceProvider(address=device.hostname,                                      port=device.port,                                      username=device.username,                                      password=device.password,                                      protocol=device.scheme)    # create CRUD service    crud = CRUDService()    telemetry_system = oc_telemetry.TelemetrySystem()  # create object    config_telemetry_system(telemetry_system)  # add object configuration    # create configuration on NETCONF device    crud.create(provider, telemetry_system)    exit()# End of scriptadmin@devbox#ydk$ Execute the YDK script#We intend to configure Model Driven Telemetry on router r1 so that it is ready to stream data associated with BGP Sessions, BGP process and IPv6 neighbor data in the above example.The Telemetry client we write later will try and receive the BGP session information from the router.Execute the YDK script, passing to it the credentials and connection details for Router r1 and its netconf port#Pass the -v option to the script to dump the requests/responses as the script executes.admin@devbox#ydk$ admin@devbox#ydk$ ./configure_telemetry_openconfig.py -v ssh#//vagrant#vagrant@10.10.20.170#83212019-01-29 21#02#48,375 - ydk - INFO - Path where models are to be downloaded# /home/admin/.ydk/10.10.20.170_83212019-01-29 21#02#48,386 - ydk - INFO - Connected to 10.10.20.170 on port 8321 using ssh with timeout of -12019-01-29 21#02#48,396 - ydk - INFO - Executing CRUD create operation on [openconfig-telemetry#telemetry-system]2019-01-29 21#02#52,735 - ydk - INFO - =============Generating payload to send to device=============2019-01-29 21#02#52,735 - ydk - INFO - &lt;rpc xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt;&lt;edit-config xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt;  &lt;target&gt;    &lt;candidate/&gt;  &lt;/target&gt;  &lt;error-option&gt;rollback-on-error&lt;/error-option&gt;  &lt;config&gt;&lt;telemetry-system xmlns=~http#//openconfig.net/yang/telemetry~ xmlns#nc=~urn#ietf#params#xml#ns#netconf#base#1.0~ nc#operation=~merge~&gt;  &lt;sensor-groups&gt;    &lt;sensor-group&gt;      &lt;sensor-group-id&gt;BGPSession&lt;/sensor-group-id&gt;      &lt;sensor-paths&gt;        &lt;sensor-path&gt;          &lt;path&gt;Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/sessions&lt;/path&gt;        &lt;/sensor-path&gt;        &lt;sensor-path&gt;          &lt;path&gt;Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/process-info&lt;/path&gt;        &lt;/sensor-path&gt;      &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;    &lt;sensor-group&gt;      &lt;sensor-group-id&gt;IPV6Neighbor&lt;/sensor-group-id&gt;      &lt;sensor-paths&gt;        &lt;sensor-path&gt;          &lt;path&gt;Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address&lt;/path&gt;        &lt;/sensor-path&gt;      &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;  &lt;/sensor-groups&gt;  &lt;subscriptions&gt;    &lt;persistent&gt;      &lt;subscription&gt;        &lt;subscription-id&gt;1&lt;/subscription-id&gt;        &lt;sensor-profiles&gt;          &lt;sensor-profile&gt;            &lt;sensor-group&gt;BGPSession&lt;/sensor-group&gt;            &lt;config&gt;              &lt;sensor-group&gt;BGPSession&lt;/sensor-group&gt;              &lt;sample-interval&gt;15000&lt;/sample-interval&gt;            &lt;/config&gt;          &lt;/sensor-profile&gt;        &lt;/sensor-profiles&gt;      &lt;/subscription&gt;      &lt;subscription&gt;        &lt;subscription-id&gt;2&lt;/subscription-id&gt;        &lt;sensor-profiles&gt;          &lt;sensor-profile&gt;            &lt;sensor-group&gt;IPV6Neighbor&lt;/sensor-group&gt;            &lt;config&gt;              &lt;sensor-group&gt;IPV6Neighbor&lt;/sensor-group&gt;              &lt;sample-interval&gt;15000&lt;/sample-interval&gt;            &lt;/config&gt;          &lt;/sensor-profile&gt;        &lt;/sensor-profiles&gt;      &lt;/subscription&gt;    &lt;/persistent&gt;  &lt;/subscriptions&gt;&lt;/telemetry-system&gt;&lt;/config&gt;&lt;/edit-config&gt;&lt;/rpc&gt;2019-01-29 21#02#52,738 - ydk - INFO - 2019-01-29 21#02#52,789 - ydk - INFO - =============Reply payload received from device=============2019-01-29 21#02#52,789 - ydk - INFO - &lt;?xml version=~1.0~?&gt;&lt;rpc-reply xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~ message-id=~1~&gt;  &lt;ok/&gt;&lt;/rpc-reply&gt;2019-01-29 21#02#52,791 - ydk - INFO - 2019-01-29 21#02#52,791 - ydk - INFO - =============Executing commit=============2019-01-29 21#02#52,791 - ydk - INFO - &lt;rpc xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt;  &lt;commit/&gt;&lt;/rpc&gt;2019-01-29 21#02#53,092 - ydk - INFO - =============Reply payload received from device=============2019-01-29 21#02#53,092 - ydk - INFO - &lt;?xml version=~1.0~?&gt;&lt;rpc-reply xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~ message-id=~2~&gt;  &lt;ok/&gt;&lt;/rpc-reply&gt;2019-01-29 21#02#53,093 - ydk - INFO - 2019-01-29 21#02#53,094 - ydk - INFO - Operation succeeded2019-01-29 21#02#53,094 - ydk - INFO - Disconnected from deviceadmin@devbox#ydk$ Check the Telemetry configuration on router r1AKSHSHAR-M-33WP#~ akshshar$ ssh -p 2221 admin@10.10.20.170--------------------------------------------------------------------------  Router 1 (Cisco IOS XR Sandbox)--------------------------------------------------------------------------Password# RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#show  running-config telemetry model-driven Wed Jan 30 05#05#03.128 UTCtelemetry model-driven sensor-group BGPSession  sensor-path Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/sessions  sensor-path Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/process-info ! sensor-group IPV6Neighbor  sensor-path Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address ! subscription 1  sensor-group-id BGPSession sample-interval 15000 ! subscription 2  sensor-group-id IPV6Neighbor sample-interval 15000 !!RP/0/RP0/CPU0#r1#Verify that the Telemetry sensor-paths are resolvedRP/0/RP0/CPU0#r1#show telemetry model-driven subscription 1Wed Jan 30 05#07#56.424 UTCSubscription#  1-------------  State#       NA  Sensor groups#  Id# BGPSession    Sample Interval#      15000 ms    Sensor Path#          Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/sessions    Sensor Path State#    Resolved    Sensor Path#          Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/process-info    Sensor Path State#    Resolved  Collection Groups#  ------------------  No active collection groupsRP/0/RP0/CPU0#r1#show telemetry model-driven subscription 2Wed Jan 30 05#07#59.312 UTCSubscription#  2-------------  State#       NA  Sensor groups#  Id# IPV6Neighbor    Sample Interval#      15000 ms    Sensor Path#          Cisco-IOS-XR-ipv6-nd-oper#ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address    Sensor Path State#    Resolved  Collection Groups#  ------------------  No active collection groupsRP/0/RP0/CPU0#r1#Awesome! You’re now ready to stream telemetry data from the above sensor-paths. Let’s proceed to run a custom python Telemetry client.Writing your own Python Telemetry clientThe Telemetry client is written based on the same concept described in the following learning lab#https#//learninglabs.cisco.com/tracks/iosxr-programmability/iosxr-streaming-telemetry/03-iosxr-02-telemetry-python/step/1We make it slightly simpler and instead of requesting telemetry data in a GPB format, we simply request json and dump it.Before we start, install the dependencies required to connect to the router over gRPC to receive the data.Install dependencies for the gRPC telemetry clientadmin@devbox#~$ sudo pip2 install grpcio-tools==1.7.0 googleapis-common-protosThe directory '/home/admin/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/admin/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Collecting grpcio-tools==1.7.0  Downloading https#//files.pythonhosted.org/packages/0e/c3/d9a9960f12e0bab789da875b1c9a3eb348b51fa3af9544c1edd1f7ef6000/grpcio_tools-1.7.0-cp27-cp27mu-manylinux1_x86_64.whl (21.3MB)    100% |████████████████████████████████| 21.3MB 50kB/s Collecting googleapis-common-protos  Downloading https#//files.pythonhosted.org/packages/61/29/1549f61917eadd11650e42b78b4afcfe9cb467157af4510ab8cb59535f14/googleapis-common-protos-1.5.6.tar.gzRequirement already satisfied (use --upgrade to upgrade)# protobuf&gt;=3.3.0 in /usr/local/lib/python2.7/dist-packages (from grpcio-tools==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# grpcio&gt;=1.7.0 in /usr/local/lib/python2.7/dist-packages (from grpcio-tools==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# setuptools in /usr/lib/python2.7/dist-packages (from protobuf&gt;=3.3.0-&gt;grpcio-tools==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# six&gt;=1.9 in /usr/lib/python2.7/dist-packages (from protobuf&gt;=3.3.0-&gt;grpcio-tools==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# enum34&gt;=1.0.4 in /usr/lib/python2.7/dist-packages (from grpcio&gt;=1.7.0-&gt;grpcio-tools==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# futures&gt;=2.2.0 in /usr/local/lib/python2.7/dist-packages (from grpcio&gt;=1.7.0-&gt;grpcio-tools==1.7.0)Installing collected packages# grpcio-tools, googleapis-common-protos  Running setup.py install for googleapis-common-protos ... doneSuccessfully installed googleapis-common-protos-1.5.6 grpcio-tools-1.7.0You are using pip version 8.1.1, however version 19.0.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.admin@devbox#~$ Clone the Telemetry gRPC collectors git repoWe have published a few samples for c++ and python to help developers write their own gRPC based collectors to receive telemetry data from IOS-XR.The proto files that we use to create bindings and then write our own clients are published here# https#//github.com/cisco/bigmuddy-network-telemetry-proto/To start, first clone the telemetry-grpc-collectors repo into the devbox home directory#admin@devbox#~$ admin@devbox#~$ git clone --recursive https#//github.com/ios-xr/telemetry-grpc-collectorsCloning into 'telemetry-grpc-collectors'...remote# Enumerating objects# 16, done.remote# Counting objects# 100% (16/16), done.remote# Compressing objects# 100% (11/11), done.remote# Total 137 (delta 4), reused 15 (delta 4), pack-reused 121Receiving objects# 100% (137/137), 3.67 MiB | 2.79 MiB/s, done.Resolving deltas# 100% (62/62), done.Checking connectivity... done.Submodule 'bigmuddy-network-telemetry-proto' (https#//github.com/cisco/bigmuddy-network-telemetry-proto) registered for path 'bigmuddy-network-telemetry-proto'Cloning into 'bigmuddy-network-telemetry-proto'...remote# Enumerating objects# 24542, done.remote# Total 24542 (delta 0), reused 0 (delta 0), pack-reused 24542Receiving objects# 100% (24542/24542), 6.06 MiB | 3.14 MiB/s, done.Resolving deltas# 100% (8337/8337), done.Checking connectivity... done.Submodule path 'bigmuddy-network-telemetry-proto'# checked out '4419cd20fb73f05d059a37fa3e41fe55f02a528f'admin@devbox#~$ Build the Bindings for Model Driven Telemetry gRPC clientsHop into the build/python/ directory and generate the required bindings from the proto files#admin@devbox#~$ admin@devbox#~$ cd telemetry-grpc-collectors/build/python/admin@devbox#python$ admin@devbox#python$ admin@devbox#python$ ./gen-mdt-dialin-bindings.sh Generating Python bindings...Doneadmin@devbox#python$ admin@devbox#python$ tree src/genpy/src/genpy/├── __init__.py├── mdt_grpc_dialin│   ├── __init__.py│   ├── mdt_grpc_dialin_pb2_grpc.py│   └── mdt_grpc_dialin_pb2.py├── mdt_grpc_dialout│   ├── __init__.py│   ├── mdt_grpc_dialout_pb2_grpc.py│   └── mdt_grpc_dialout_pb2.py├── telemetry_pb2_grpc.py└── telemetry_pb2.py2 directories, 9 filesadmin@devbox#python$ Running a simple python Telemetry clientHop into the clients/python/ directory and dump the telemetry_client_json.py script which is written to connect to an IOS-XR router over gRPC, request a json data-stream and dump it to the screen.The script is dumped below.admin@devbox#~$ admin@devbox#~$ cd ~/telemetry-grpc-collectors/clients/python/admin@devbox#python$ lstelemetry_client_json.py  telemetry_client.pyadmin@devbox#python$ cat telemetry_client_json.py #!/usr/bin/env python# Standard python libsimport os,syssys.path.append(~../../build/python/src/genpy~)import ast, pprint import pdbimport yaml, jsonimport telemetry_pb2from mdt_grpc_dialin import mdt_grpc_dialin_pb2from mdt_grpc_dialin import mdt_grpc_dialin_pb2_grpcimport grpc ## Get the GRPC Server IP address and port number#def get_server_ip_port()#    # Get GRPC Server's IP from the environment    if 'SERVER_IP' not in os.environ.keys()#        print(~Need to set the SERVER_IP env variable e.g.~)        print(~export SERVER_IP='10.30.110.214'~)        os._exit(0)        # Get GRPC Server's Port from the environment    if 'SERVER_PORT' not in os.environ.keys()#        print(~Need to set the SERVER_PORT env variable e.g.~)        print(~export SERVER_PORT='57777'~)        os._exit(0)        return (os.environ['SERVER_IP'], int(os.environ['SERVER_PORT']))## Setup the GRPC channel with the server, and issue RPCs#if __name__ == '__main__'#    server_ip, server_port = get_server_ip_port()    print(~Using GRPC Server IP(%s) Port(%s)~ %(server_ip, server_port))    # Create the channel for gRPC.    channel = grpc.insecure_channel(str(server_ip)+~#~+str(server_port))    unmarshal = True    # Ereate the gRPC stub.    stub = mdt_grpc_dialin_pb2_grpc.gRPCConfigOperStub(channel)    metadata = [('username', 'vagrant'), ('password', 'vagrant')]    Timeout = 3600*24*365 # Seconds    sub_args = mdt_grpc_dialin_pb2.CreateSubsArgs(ReqId=99, encode=4, subidstr='1')    stream = stub.CreateSubs(sub_args, timeout=Timeout, metadata=metadata)    for segment in stream#        if not unmarshal#            print(segment)        else#            # Go straight for telemetry data            telemetry_pb = telemetry_pb2.Telemetry()            encoding_path = 'Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/'+\\                            'instance/instance-active/default-vrf/sessions/session'            try#                # Return in JSON format instead of protobuf.                if json.loads(segment.data)[~encoding_path~] == encoding_path#                     print(json.dumps(json.loads(segment.data), indent=3))            except Exception as e#                 print(~Failed to receive data, error# ~ +str(e))    os._exit(0)admin@devbox#python$ Finally, open up a new shell and run this script to start receiving data from IOS-XR.Make sure you export the connection details for the gRPC server running on router r1 before running the script.export SERVER_IP=10.10.20.170export SERVER_PORT=57021admin@devbox#python$ admin@devbox#python$ export SERVER_IP=10.10.20.170admin@devbox#python$ export SERVER_PORT=57021admin@devbox#python$ admin@devbox#python$ ./telemetry_client_json.py Using GRPC Server IP(10.10.20.170) Port(57021){   ~encoding_path~# ~Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/sessions/session~,    ~subscription_id_str~# ~1~,    ~collection_start_time~# 1548827148102,    ~msg_timestamp~# 1548827148108,    ~collection_end_time~# 1548827148108,    ~node_id_str~# ~r1~,    ~data_json~# [      {         ~keys~# {            ~neighbor-address~# ~60.1.1.1~,             ~instance-name~# ~default~         },          ~timestamp~# 1548827148107,          ~content~# {            ~messages-queued-in~# 0,             ~is-local-address-configured~# false,             ~local-as~# 65000,             ~nsr-state~# ~bgp-nbr-nsr-st-none~,             ~description~# ~~,             ~connection-remote-address~# {               ~ipv4-address~# ~60.1.1.1~,                ~afi~# ~ipv4~            },             ~messages-queued-out~# 0,             ~connection-state~# ~bgp-st-idle~,             ~speaker-id~# 0,             ~vrf-name~# ~default~,             ~remote-as~# 65000,             ~postit-pending~# false,             ~nsr-enabled~# true,             ~connection-local-address~# {               ~ipv4-address~# ~0.0.0.0~,                ~afi~# ~ipv4~            }         }      }   ],    ~collection_id~# 16}Perfect! Now, we’re all set up to deploy Open/R as an application on the two routers and test out Application-hosting, packet-io and Service-Layer APIs in XR together.",
      "url": "/wkinstructions/2019-02-01-step-5-playing-iosxr-Yang-Models/",
      "author": "Akshat Sharma",
      "tags": "iosxr, cisco, devnet, cleur2019"
    }
    
    ,
  
  
  
    "wkinstructions-2019-02-01-step-6-quick-look-at-ios-xr-service-layer-api": {
      "title": "Step 6: Quick Look at IOS-XR Service-Layer API",
      "content": "     On This Page  What is the Service-Layer API ?  Client Code# Install gRPC and regenerate bindings          Connect to the Devbox      Clone the Service-Layer Object Model Repository      Install the Protobuf compiler      Install grpc tools      View .proto files (models)      Generate Python bindings        Client Code# Running existing tutorials          Install grpcio and ipaddress packages                  For python2          For Python3                    Running pre-packaged tutorials                  List the existing tutorials          Basic Client Initialization# client_init.py          Register/Unregister against the Route Vertical# vrf.py          Add Routes to IOS-XR RIB# quickstart.py          Add Routes to IOS-XR RIB# route.py          Register and Listen for interface state events# interface.py          Allocate Local labels and Create ILM entries# mpls_ilm.py                        Have a look at the set of Service-Layer learning labs on DevNet for more details on the Service-Layer API, associated configuration, details on writing your own gRPC clients in pythonm, c++ and more.https#//learninglabs.cisco.com/modules/iosxr-service-layerWhat is the Service-Layer API ?Let’s focus on the Service Adaptation layer from the earlier breakdown of the stack#    The API offered to the end-user by the Service Adaptation layer is called the Service-Layer API. This API is quite distinct from the Management/Manageability layer APIs (CLI, Yang Models, Telemetry) in the sense that these APIs are not tied to the IOS-XR internal database called SYSDB.This is shown in the figure below. The Manageability Layer derives its capabilities from SYSDB - The CLI and the YANG models are essentially interaction points for SYSDB data models representing the configuration and operational state of IOS-XR features and capabilities.    The Service-Layer API, however, is distinct. It gives the end-user access directly to the Network Infrastructure Layer (Service-Adaptation Layer), completely bypassing SYSDB.This leads to some inherent characteristics of the Service Layer API#      By not being tied to SYSDB, the Service-Layer APIs expose just the right amount of capabilities without being tied to the “feature knobs” supported by SYSDB. You get to control the state machine within the controller/agent/app that acts as a client to the Service-Layer API.        By providing an API directly into the Network Infrastructure layer, when a client interacts with the API the number of layers that the request and subsequent calls have to traverse is lower compared to Manageability Layer APIs. As a result, Service Layer APIs are able to afford a very level of performance. We will showcase this when we utilize the API to program routes into IOS-XR RIB.  So, why do we need another API? A couple of customer(unnamed) quotes for your consumption#  “The multiple layers in the stack get in the way – We need better performance!”  “I have my own controller/protocol, just give me complete access to the infrastructure underneath”  Connect to your Pod first! Make sure your Anyconnect VPN connection to the Pod assigned to you is active.  If you haven’t connected yet, check out the instructions to do so here#https#//sevt-sp.github.io/xr-programmability-lab/connect-to-pods/  Once you’re connected, use the following instructions to connect to the individual nodes.The instructions in the workshop will simply refer to the Name of the box to connect withoutrepeating the connection details and credentials. So refer back to this list when you need it.  The 3 nodes in the topology are#  Development Linux System (DevBox)   IP Address# 10.10.20.170 Username/Password# [admin/admin] SSH Port# 2211    IOS-XRv9000 R1# (Router r1)  IP Address# 10.10.20.170  Username/Password# [admin/admin]   Management IP# 10.10.20.170  XR SSH Port# 2221    NETCONF Port# 8321   gRPC Port# 57021  XR-Bash SSH Port# 2222        IOS-XRv9000 R2#  (Router r2)  IP Address# 10.10.20.170   Username/Password# [admin/admin]   Management IP# 10.10.20.170   XR SSH Port# 2231    NETCONF Port# 8331   gRPC Port# 57031    XR-Bash SSH Port# 2232  The Topology in use is shown below#Client Code# Install gRPC and regenerate bindingsWe will develop and run the service-layer python clients on the devbox. The sl-api client will connect to the router over gRPC. So, the steps we intend to perform as part of this section are#      Install the protoc compiler python-pip provides protoc using a grpc-tools package that we intend to use. Alternatively protoc can be built using protobuf#3.5.0 package from github.        Provide the model (.proto) files to the compiler and generate bindings (i.e. actual code in the form of .py files from the .proto files). This generated code is then used as a set of libraries to create our own client code.  The process is depicted below#![protoc_compilation.png]Connect to the DevboxOur next set of tasks will be performed on the devbox. Connection details are explained in the beginning of this lab. SSH into devbox#Username# adminPassword# adminSSH port# 2211Laptop-Terminal#$ ssh -p 2211 admin@10.10.20.170admin@10.10.20.170's password#Last login# Sun Aug 26 19#18#39 2018 from 192.168.122.1admin@devbox#~$admin@devbox#~$Clone the Service-Layer Object Model RepositoryAs described in the 1st lab of this module, titled# Service-Layer APIs# Bring your own Protocol/Controller, the Service-Layer API is model-driven and uses protobuf IDLs to represent the models. These proto definitions can be found here#  https#//github.com/Cisco-Service-Layer/service-layer-objmodel/tree/master/grpc/protosClone this git repository onto the devbox. We will clone the release v0.0.1.admin@devbox#~$ git clone https#//github.com/Cisco-Service-Layer/service-layer-objmodel.git -b v0.0.1Cloning into 'service-layer-objmodel'...remote# Counting objects# 402, done.remote# Compressing objects# 100% (45/45), done.remote# Total 402 (delta 42), reused 44 (delta 25), pack-reused 332Receiving objects# 100% (402/402), 7.60 MiB | 3.01 MiB/s, done.Resolving deltas# 100% (214/214), done.Checking connectivity... done.admin@devbox#~$Install the Protobuf compilerFor python, the protobuf compiler (protoc) utility is packaged into the following pip-installable tool# grpcio-tools. We also need to install the tool googleapis-common-protos which contains python classes generated from protos in the googleapis repository.These tools are identified in the instructions laid out on https#//grpc.io for python client/server code generation#  https#//grpc.io/docs/tutorials/basic/python.html#generating-client-and-server-codeThe gRPC version that must be used for the client code is closely tied to the gRPC version used by the server code present in a given IOS-XR release.  **In the IOS-XR Progammability sandbox, the routers are running IOS-XR release 6.4.1 which utilizes the gRPC version=`1.7.0`.  Hence `grpcio` and the `grpcio-tools` package selected for this lab will have version=`1.7.0`**Install grpc toolsThe goal is to create bindings that are compatible for both python2 and python3 environments.Owing to this issue#  https#//github.com/protocolbuffers/protobuf/issues/1491it makes sense to generate bindings using python2 and transform them to a compatible state for python3 using the tool# 2to3.Therefore, installing grpcio-tools and googleapis-common-protos first for python2 (use pip2 to install packages for python2)#Ignore the warnings related to pip permissions and version. They are harmless.admin@devbox#~$ sudo pip2 install grpcio-tools==1.7.0 googleapis-common-protosThe directory '/home/admin/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/admin/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Collecting grpcio-tools==1.7.0  Downloading https#//files.pythonhosted.org/packages/0e/c3/d9a9960f12e0bab789da875b1c9a3eb348b51fa3af9544c1edd1f7ef6000/grpcio_tools-1.7.0-cp27-cp27mu-manylinux1_x86_64.whl (21.3MB)    100% |████████████████████████████████| 21.3MB 47kB/sCollecting googleapis-common-protos  Downloading https#//files.pythonhosted.org/packages/00/03/d25bed04ec8d930bcfa488ba81a2ecbf7eb36ae3ffd7e8f5be0d036a89c9/googleapis-common-protos-1.5.3.tar.gzRequirement already satisfied (use --upgrade to upgrade)# protobuf&gt;=3.3.0 in /usr/local/lib/python2.7/dist-packages (from grpcio-tools==1.7.0)Collecting grpcio&gt;=1.7.0 (from grpcio-tools==1.7.0)  Downloading https#//files.pythonhosted.org/packages/b5/84/c0d0a0355f2e3ea1e49fd81aa123e0bf42bfaa58be56583cc3b9baaf2837/grpcio-1.14.1-cp27-cp27mu-manylinux1_x86_64.whl (9.2MB)    100% |████████████████████████████████| 9.2MB 120kB/sRequirement already satisfied (use --upgrade to upgrade)# setuptools in /usr/lib/python2.7/dist-packages (from protobuf&gt;=3.3.0-&gt;grpcio-tools==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# six&gt;=1.9 in /usr/lib/python2.7/dist-packages (from protobuf&gt;=3.3.0-&gt;grpcio-tools==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# enum34&gt;=1.0.4 in /usr/lib/python2.7/dist-packages (from grpcio&gt;=1.7.0-&gt;grpcio-tools==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# futures&gt;=2.2.0 in /usr/local/lib/python2.7/dist-packages (from grpcio&gt;=1.7.0-&gt;grpcio-tools==1.7.0)Installing collected packages# grpcio, grpcio-tools, googleapis-common-protos  Running setup.py install for googleapis-common-protos ... doneSuccessfully installed googleapis-common-protos-1.5.3 grpcio-1.14.1 grpcio-tools-1.7.0You are using pip version 8.1.1, however version 18.0 is available.You should consider upgrading via the 'pip install --upgrade pip' command.admin@devbox#~$admin@devbox#~$View .proto files (models)Let’s take a look at the .proto files that are packaged as part of the cloned repository#admin@devbox#$ cd service-layer-objmodeladmin@devbox#service-layer-objmodel$ pwd/home/admin/service-layer-objmodeladmin@devbox#service-layer-objmodel$ cd grpc/protos/admin@devbox#protos$ ls -ltotal 116-rw-rw-r-- 1 admin admin  4810 Aug 27 04#40 sl_bfd_common.proto-rw-rw-r-- 1 admin admin  6918 Aug 27 04#40 sl_bfd_ipv4.proto-rw-rw-r-- 1 admin admin  6916 Aug 27 04#40 sl_bfd_ipv6.proto-rw-rw-r-- 1 admin admin 23285 Aug 27 04#40 sl_common_types.proto-rw-rw-r-- 1 admin admin  6150 Aug 27 04#40 sl_global.proto-rw-rw-r-- 1 admin admin  8068 Aug 27 04#40 sl_interface.proto-rw-rw-r-- 1 admin admin 17521 Aug 27 04#40 sl_mpls.proto-rw-rw-r-- 1 admin admin  9912 Aug 27 04#40 sl_route_common.proto-rw-rw-r-- 1 admin admin  7203 Aug 27 04#40 sl_route_ipv4.proto-rw-rw-r-- 1 admin admin  7165 Aug 27 04#40 sl_route_ipv6.proto-rw-rw-r-- 1 admin admin   713 Aug 27 04#40 sl_version.protoadmin@devbox#protos$ lsBriefly, these protobuf models cover the following capabilities#            Functionality Vertical      Proto File      Supported RPCs                  Common across Verticals      sl_common_types.proto      Defines common data structures for all verticals, such as Error codes, Operation codes (registration, notification etc.), and structures for XR interfaces and ip-addresses.              Common across Verticals      sl_version.proto      Contains an enum specifying the current Version of SL-API. Current Version=v0.0.1              Initialization      sl_global.proto      RPCs to fetch global information related to different functionality verticals and global limits and to create and mantain an initialization channel with IOS-XR service-layer over gRPC              Interface      sl_interface.proto      RPCs and data structures(messages) to get global and specific interface states, to enable/disable event notifications for specific interfaces and to register for interface state events              MPLS      sl_mpls.proto      RPCs to register against the MPLS vertical, allocate or delete label blocks and manipulate ILM (incoming Label Map) to forwarding function entries. It also defines all the data structures used by the MPLS vertical’s RPCs              Route      sl_route_common.proto      Defines data structures (messages) that are used by the Route vertical’s RPCs. These data structures include Registration objects (to register against the route vertical for a given VRF), VRF objects, and common Router and Path objects utilized by both IPv4 and IPv6 Route proto files.              Route      sl_route_ipv4.proto      Defines the RPC calls for IPv4 route changes (adding, deleting and getting IPv4 routes) and VRF registration - essential before one can manipulate routes in the IOS-XR RIB.              Route      sl_route_ipv6.proto      Defines the RPC calls for IPv6 route changes (adding, deleting and getting IPv6 routes) and VRF registration - essential before one can manipulate routes in the IOS-XR RIB.              BFD      sl_bfd_common.proto      Defines data structures (messages) that are used by the BFD vertical’s RPCs. These data structures include Registration objects (to register against the BFD vertical), State Objects (to identify a BFD event), Get objects and Set(Tx Interval Manipulation) Objects.              BFD      sl_bfd_ipv4.proto      Defines the RPCs for adding, deleting, updating, and retrieving BFD sessions# used for IPv4 BFD registrations, and BFD session operations and notifications.              BFD      sl_bfd_ipv6.proto      Defines the RPCs for adding, deleting, updating, and retrieving BFD sessions# used for IPv6 BFD registrations, and BFD session operations and notifications.      Generate Python bindingsHop into the grpc/python directory under the cloned git repo. You will find the gen-bindings.sh script.The contents of this script are dumped below#admin@devbox#python$ pwd/home/admin/service-layer-objmodel/grpc/pythonadmin@devbox#python$admin@devbox#python$ cat gen-bindings.sh#!/bin/bash## Copyright (c) 2016 by cisco Systems, Inc.# All rights reserved.##Clean up the Bindings firstrm -rf ./src/genpy/*touch ./src/genpy/__init__.pycd ../protosprintf ~Generating Python bindings...~for proto_file in *.protodo  python -m grpc_tools.protoc -I ./ --python_out=../python/src/genpy/ --grpc_python_out=../python/src/genpy/ $proto_filedonecd ../python/src/genpy2to3 -w * &gt;/dev/null 2&gt;&amp;1echo ~Done~admin@devbox#python$It can be seen that the gen-bindings.sh script first cleans up the existing genpy/ directory where the bindings will be created and then proceeds to loop through the proto files running the protoc utility from the grpc_tools package. Once done, the 2to3 tool is run to convert all the generated bindings under genpy/ from only-python2 to python2-and-python3 compatible.admin@devbox#python$admin@devbox#python$ ./gen-bindings.shGenerating Python bindings...Doneadmin@devbox#python$Once the gen-bindings.sh script has been run, jump to the genpy folder and you should see the generated bindings#admin@devbox#python$admin@devbox#python$ pwd/home/admin/service-layer-objmodel/grpc/pythonadmin@devbox#python$admin@devbox#python$ cd src/genpy/admin@devbox#genpy$admin@devbox#genpy$ ls -ltotal 384-rw-rw-r-- 1 admin admin     0 Aug 27 03#30 __init__.py-rw-rw-r-- 1 admin admin    83 Aug 27 03#30 sl_bfd_common_pb2_grpc.py-rw-rw-r-- 1 admin admin 19890 Aug 27 03#30 sl_bfd_common_pb2.py-rw-rw-r-- 1 admin admin  7457 Aug 27 03#30 sl_bfd_ipv4_pb2_grpc.py-rw-rw-r-- 1 admin admin 25091 Aug 27 03#30 sl_bfd_ipv4_pb2.py-rw-rw-r-- 1 admin admin  7457 Aug 27 03#30 sl_bfd_ipv6_pb2_grpc.py-rw-rw-r-- 1 admin admin 25105 Aug 27 03#30 sl_bfd_ipv6_pb2.py-rw-rw-r-- 1 admin admin    83 Aug 27 03#30 sl_common_types_pb2_grpc.py-rw-rw-r-- 1 admin admin 44543 Aug 27 03#30 sl_common_types_pb2.py-rw-rw-r-- 1 admin admin  3398 Aug 27 03#30 sl_global_pb2_grpc.py-rw-rw-r-- 1 admin admin 16448 Aug 27 03#30 sl_global_pb2.py-rw-rw-r-- 1 admin admin  7477 Aug 27 03#30 sl_interface_pb2_grpc.py-rw-rw-r-- 1 admin admin 30041 Aug 27 03#30 sl_interface_pb2.py-rw-rw-r-- 1 admin admin 10917 Aug 27 03#30 sl_mpls_pb2_grpc.py-rw-rw-r-- 1 admin admin 45631 Aug 27 03#30 sl_mpls_pb2.py-rw-rw-r-- 1 admin admin    83 Aug 27 03#30 sl_route_common_pb2_grpc.py-rw-rw-r-- 1 admin admin 28853 Aug 27 03#30 sl_route_common_pb2.py-rw-rw-r-- 1 admin admin 10197 Aug 27 03#30 sl_route_ipv4_pb2_grpc.py-rw-rw-r-- 1 admin admin 20694 Aug 27 03#30 sl_route_ipv4_pb2.py-rw-rw-r-- 1 admin admin 10197 Aug 27 03#30 sl_route_ipv6_pb2_grpc.py-rw-rw-r-- 1 admin admin 20715 Aug 27 03#30 sl_route_ipv6_pb2.py-rw-rw-r-- 1 admin admin    83 Aug 27 03#30 sl_version_pb2_grpc.py-rw-rw-r-- 1 admin admin  2204 Aug 27 03#30 sl_version_pb2.pyadmin@devbox#genpy$It is important to understand what these bindings imply. These bindings are generated from the proto files that are described above and represent the python libraries that can be imported into your client code to provide the RPCs to be used to interact with the required functionality vertical. Perfect! We are now ready to start running existing tutorials and analyze how to write our own.Client Code# Running existing tutorialsIn the cloned service-layer-objmodel git repo, there are several python tutorials showcasing how you can connect and utilize the various RPCs defined in the proto files (and therefore in the bindings we generated in the previous section).Install grpcio and ipaddress packagesBefore we try running the clients, install the necessary packages.The grpcio package is a must to actually create a channel and connect to the router over gRPC. As mentioned in the previous section, the version of gRPC used is 1.7.0. The ipaddress python package (or py2-ipaddress for python2) will be used to manage ip addresses in python for some of the client examples we intend to run.For python2Version of grpcio=1.7.0. For python2, ipaddress module is actually py2-ipaddress. Use pip2 to install packages for python2.admin@devbox#~$admin@devbox#~$ sudo pip2 install grpcio==1.7.0 py2-ipaddressThe directory '/home/admin/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/admin/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Collecting grpcio==1.7.0  Downloading https#//files.pythonhosted.org/packages/44/52/e5efd5f7adcfc41967691e296df8b1a96549c8a7f0fa5cf0b23204dcca07/grpcio-1.7.0-cp27-cp27mu-manylinux1_x86_64.whl (5.7MB)    100% |████████████████████████████████| 5.7MB 201kB/sCollecting py2-ipaddress  Downloading https#//files.pythonhosted.org/packages/06/f2/ff20f2d2fd4757be329c8ecb81e9e7fa3bec0b65445821e3a575410cf194/py2-ipaddress-3.4.1.tar.gzRequirement already satisfied (use --upgrade to upgrade)# six&gt;=1.5.2 in /usr/lib/python2.7/dist-packages (from grpcio==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# enum34&gt;=1.0.4 in /usr/lib/python2.7/dist-packages (from grpcio==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# protobuf&gt;=3.3.0 in /usr/local/lib/python2.7/dist-packages (from grpcio==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# futures&gt;=2.2.0 in /usr/local/lib/python2.7/dist-packages (from grpcio==1.7.0)Requirement already satisfied (use --upgrade to upgrade)# setuptools in /usr/lib/python2.7/dist-packages (from protobuf&gt;=3.3.0-&gt;grpcio==1.7.0)Installing collected packages# grpcio, py2-ipaddress  Found existing installation# grpcio 1.14.1    Uninstalling grpcio-1.14.1#      Successfully uninstalled grpcio-1.14.1  Running setup.py install for py2-ipaddress ... doneSuccessfully installed grpcio-1.7.0 py2-ipaddress-3.4.1You are using pip version 8.1.1, however version 18.0 is available.You should consider upgrading via the 'pip install --upgrade pip' command.admin@devbox#~$admin@devbox#~$For Python3Version of grpcio=1.7.0. For python3, ipaddress module is just ipaddress. Use pip3 to install packages for python3.admin@devbox#~$admin@devbox#~$ sudo pip3 install grpcio==1.7.0 ipaddressThe directory '/home/admin/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/admin/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Collecting grpcio==1.7.0  Downloading https#//files.pythonhosted.org/packages/17/69/0c06ee99a7df3814520c94014a6e0b2ee4b997f88970aca9e4c072b5672a/grpcio-1.7.0-cp35-cp35m-manylinux1_x86_64.whl (5.7MB)    100% |████████████████████████████████| 5.7MB 7.3MB/sCollecting ipaddress  Downloading https#//files.pythonhosted.org/packages/fc/d0/7fc3a811e011d4b388be48a0e381db8d990042df54aa4ef4599a31d39853/ipaddress-1.0.22-py2.py3-none-any.whlRequirement already satisfied# six&gt;=1.5.2 in /usr/lib/python3/dist-packages (from grpcio==1.7.0) (1.10.0)Requirement already satisfied# protobuf&gt;=3.3.0 in /usr/local/lib/python3.5/dist-packages (from grpcio==1.7.0) (3.6.1)Requirement already satisfied# setuptools in /usr/lib/python3/dist-packages (from protobuf&gt;=3.3.0-&gt;grpcio==1.7.0) (20.7.0)Installing collected packages# grpcio, ipaddressSuccessfully installed grpcio-1.7.0 ipaddress-1.0.22You are using pip version 10.0.1, however version 18.0 is available.You should consider upgrading via the 'pip install --upgrade pip' command.admin@devbox#~$admin@devbox#~$Running pre-packaged tutorialsLet’s run some of the representative tutorials that are packaged along with the service-layer-objmodel git repo and see if things are working well. We will also run some commands on the router r1 (that we intend to connect to) in order to understand the effect of programming IOS-XR using the service-layer API.List the existing tutorialsThe existing tutorials are shown below in the grpc/python/src/tutorial directory under the git repo service-layer-objmodel.admin@devbox#python$ pwd/home/admin/service-layer-objmodel/grpc/pythonadmin@devbox#python$admin@devbox#python$admin@devbox#python$admin@devbox#python$ cd src/tutorial/admin@devbox#tutorial$admin@devbox#tutorial$admin@devbox#tutorial$ ls -ltotal 88-rw-rw-r-- 1 admin admin  5823 Aug 27 04#40 client_init.pydrwxrwxr-x 2 admin admin  4096 Aug 27 04#40 grpc_beta-rw-rw-r-- 1 admin admin    72 Aug 27 04#40 __init__.py-rw-rw-r-- 1 admin admin 12698 Aug 27 04#40 interface.py-rw-rw-r-- 1 admin admin 10329 Aug 27 04#40 mpls_ilm.py-rw-rw-r-- 1 admin admin  5435 Aug 27 04#40 quickstart.py-rw-rw-r-- 1 admin admin 14211 Aug 27 04#40 README.md-rw-rw-r-- 1 admin admin 12857 Aug 27 04#40 route.py-rw-rw-r-- 1 admin admin  3617 Aug 27 04#40 vrf.pyadmin@devbox#tutorial$admin@devbox#tutorial$  All the tutorials described below, expect the following environment variables to be set before running them#      SERVER_IP# IP address over which the router’s gRPC server is reachable    SERVER_PORT# TCP port over which the router’s gRPC server is reachable To set these variables, simply export them in the shell of the admin box before running the &gt;tutorials (The tutorials will ask you to if you miss this)#      admin@devbox#tutorial$admin@devbox#tutorial$ export SERVER_IP=10.10.20.170admin@devbox#tutorial$ export SERVER_PORT=57021admin@devbox#tutorial$            These tutorials cover the following use cases#Basic Client Initialization# client_init.pyThis tutorial utilizes the initialization RPC to set up a notification channel with the service-layer gRPC server running on the router. This notification channel is used by the client to be notified of any server error conditions or any disconnect messages. You canNOT utilize any of the service-layer functionality verticals if you don’t keep a notification channel active.This is usually done by initiating the notification channel in a separate thread inside your code, so that the rest of code can continue to execute while the notification channel remains active within the thread.Most modern programming languages (certainly python, c++, golang) have concepts of parallel processes such as threads to enable this functionality.client_init.py will simply connect, set up a channel and disconnect. Its init code will be run inside a separate thread in the next set of tutorials that leverage it.Version `v0.0.1` of the Service-Layer API supports only one client connection at a time. So if another client connects to the service-layer (version `v0.0.1`), a disconnect message will be sent to the existing client over the notification channel Run client_init.py#admin@devbox#tutorial$admin@devbox#tutorial$admin@devbox#tutorial$ python3 client_init.pyUsing GRPC Server IP(10.10.20.170) Port(57021)Global thread spawnedServer Returned 0x502, Version 0.0.0  Successfully Initialized, connection established!Max VRF Name Len     # 33Max Iface Name Len   # 64Max Paths per Entry  # 64Max Prim per Entry   # 32Max Bckup per Entry  # 32Max Labels per Entry # 3Min Prim Path-id     # 1Max Prim Path-id     # 64Min Bckup Path-id    # 65Max Bckup Path-id    # 128Max Remote Bckup Addr# 2admin@devbox#tutorial$Perfect, the client was able to connect to the Service-layer, set up a channel, glean some global limits associated with the different functionality verticals and dump them, before disconnecting. Register/Unregister against the Route Vertical# vrf.pyThis tutorial utilizes the client_init.py code to maintain the notification channel for it while it proceeds to register against a particular vrf (vrf default). This accomplishes registration for the Route vertical described earlier.Only post registration with the Route vertical can the RIB manipulations be carried out.One must register against a functionality vertical first. Only post registration, would the RPCs for that vertical work.Run vrf.py#admin@devbox#tutorial$admin@devbox#tutorial$ python3 vrf.pyUsing GRPC Server IP(10.10.20.170) Port(57021)Global thread spawnedServer Returned 0x502, Version 0.0.0Successfully Initialized, connection established!Max VRF Name Len     # 33Max Iface Name Len   # 64Max Paths per Entry  # 64Max Prim per Entry   # 32Max Bckup per Entry  # 32Max Labels per Entry # 3Min Prim Path-id     # 1Max Prim Path-id     # 64Min Bckup Path-id    # 65Max Bckup Path-id    # 128Max Remote Bckup Addr# 2VRF SL_REGOP_REGISTER Success!VRF SL_REGOP_EOF Success!VRF SL_REGOP_UNREGISTER Success!admin@devbox#tutorial$The initial dump is the same as the earlier run of client_init.py since vrf.py utilizes client_init.py.  The last set of messages show that the client was able to#  Successfully Register for the Route vertical (for vrf# default)  Send an EOF (used to flush out stale routes - marked by the registration process- should remind folks of the  Mark and Sweep technique used in Garbage Collection algorithms. This is utilized whenever controllers/clients intend to resync routes with the IOS-XR RIB in the event of either a client or server failure.)  Successfully Unregister for the Route Vertical (used to disconnect and flush out all the routes from the particular vrf) Add Routes to IOS-XR RIB# quickstart.pyThe quickstart.py tutorial uses vrf.py (which in turn uses client_init.py as mentioned above) to register against the Route vertical. It then utilizes RPCs in the IPv4 Route vertical to program IPv4 routes into the IOS-XR RIB.Run quickstart.py# admin@devbox#tutorial$ python3 quickstart.py Using GRPC Server IP(10.10.20.170) Port(57021) Global thread spawned Server Returned 0x502, Version 0.0.0 Successfully Initialized, connection established! Max VRF Name Len     # 33 Max Iface Name Len   # 64 Max Paths per Entry  # 64 Max Prim per Entry   # 32 Max Bckup per Entry  # 32 Max Labels per Entry # 3 Min Prim Path-id     # 1 Max Prim Path-id     # 64 Min Bckup Path-id    # 65 Max Bckup Path-id    # 128 Max Remote Bckup Addr# 2 VRF SL_REGOP_REGISTER Success! VRF SL_REGOP_EOF Success! Route SL_OBJOP_ADD Success! admin@devbox#tutorial$Perfect! The first few messages would remind you of the output from the vrf.py tutorial above. We do not Unregister here, but instead utilize the Route vertical to push some route objects into the IOS-XR RIB.To verify this, ssh into the router and do a dump of the RIB using show route#Username# adminPassword# adminSSH port# 2221  Laptop-terminal$ ssh -p 2221 admin@10.10.20.170 ------------------------------------------------------------------------ Router 1 (Cisco IOS XR Sandbox) ------------------------------------------------------------------------ Password# RP/0/RP0/CPU0#r1# RP/0/RP0/CPU0#r1#show  route Sun Sep  2 00#49#39.882 UTC Codes# C - connected, S - static, R - RIP, B - BGP, (&gt;) - Diversion path        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area        N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2        E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP        i - ISIS, L1 - IS-IS level-1, L2 - IS-IS level-2        ia - IS-IS inter area, su - IS-IS summary null, * - candidate default        U - per-user static route, o - ODR, L - local, G  - DAGR, l - LISP        A - access/subscriber, a - Application route        M - mobile route, r - RPL, t - Traffic Engineering, (!) - FRR Backup path Gateway of last resort is 192.168.122.1 to network 0.0.0.0 S*   0.0.0.0/0 [1/0] via 192.168.122.1, 5d13h a    20.0.0.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.1.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.2.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.3.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.4.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.5.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.6.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.7.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.8.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 a    20.0.9.0/24 [2/0] via 10.10.10.1, 00#04#31, GigabitEthernet0/0/0/0                  [2/0] via 10.10.10.2, 00#04#31, GigabitEthernet0/0/0/0 C    192.168.122.0/24 is directly connected, 5d13h, MgmtEth0/RP0/CPU0/0 L    192.168.122.21/32 is directly connected, 5d13h, MgmtEth0/RP0/CPU0/0 RP/0/RP0/CPU0#r1#Notice the `a` routes in the RIB. These were the routes pushed into the RIB by the `quickstart.py` client.  Add Routes to IOS-XR RIB# route.pyThis tutorial is a combination of client_init.py, vrf.py and quickstart.py into a single piece of code. We will not run this tutorial as part of the lab but it useful to look at to see how to combine the 3 pieces of code above. Register and Listen for interface state events# interface.pyThis tutorial showcases how to register against the interface vertical, set up event streams for a certain set of interfaces and then start thread to receive notifications of interface events as we shut/no-shut registered interfaces.Run interface.py#admin@devbox#tutorial$ python3 interface.pyUsing GRPC Server IP(10.10.20.170) Port(57021)Global thread spawnedServer Returned 0x502, Version 0.0.0Successfully Initialized, connection established!Max VRF Name Len     # 33Max Iface Name Len   # 64Max Paths per Entry  # 64Max Prim per Entry   # 32Max Bckup per Entry  # 32Max Labels per Entry # 3Min Prim Path-id     # 1Max Prim Path-id     # 64Min Bckup Path-id    # 65Max Bckup Path-id    # 128Max Remote Bckup Addr# 2ErrStatus {}ErrStatus {}StatusSummary {}ErrStatus {}MaxInterfacesPerBatch# 1024Eof# trueErrStatus {}Entries { SLIfInfo {   Name# ~GigabitEthernet0/0/0/0~ }}Entries { SLIfInfo {   Name# ~GigabitEthernet0/0/0/1~ }}Entries { SLIfInfo {   Name# ~MgmtEth0/RP0/CPU0/0~ }}Starting listener for interface eventsWe register for the state events of three interfaces, namely#  GigabitEthernet0/0/0/0, GigabitEthernet0/0/0/1 and MgmtEth0/RP0/CPU0/0.You will notice that the client is still running, because it is listening for interface state events in a persistent thread. Let’s trigger the shut/no-shut of interface GigabitEthernet0/0/0/0 and see how the client reacts.Connect to the router r1 in a separate terminal while the client is running and shut down interface Gig0/0/0/0#Username# adminPassword# adminSSH port# 2221Laptop-terminal$ ssh -p 2221 admin@10.10.20.170------------------------------------------------------------------------Router 1 (Cisco IOS XR Sandbox)------------------------------------------------------------------------Password#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#conf tSun Sep  2 01#24#29.685 UTCRP/0/RP0/CPU0#r1(config)#int  gigabitEthernet 0/0/0/0RP/0/RP0/CPU0#r1(config-if)#shutRP/0/RP0/CPU0#r1(config-if)#commitSun Sep  2 01#24#35.402 UTCRP/0/RP0/CPU0#r1(config-if)#Hop back to the running client, and you should notice the following message show up#Received HeartBeatReceived HeartBeatEventType# SL_INTERFACE_EVENT_TYPE_INTERFACE_INFOInfo { SLIfInfo {   Name# ~GigabitEthernet0/0/0/0~ } IfState# SL_IF_STATE_DOWN SeqNum# 11}The Received HeartBeat messages show up as the client receives heartbeats periodically from the Server.  The event SL_INTERFACE_EVENT_TYPE_INTERFACE_INFO gives us more information on the type of interface event received#  It is for the interface GigabitEthernet0/0/0/0 and  It was a DOWN event# IfState# SL_IF_STATE_DOWN  The sequence number# SeqNum# 11 illustrates the sequence number of this event message - can be used to correlate events in a sequence of interface events (for e.g. in case of flapping interfaces).Similarly, no-shut the interface GigabitEthernet0/0/0/0 on the router and notice the UP event being streamed to the client#Router r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#conf tSun Sep  2 01#24#29.685 UTCRP/0/RP0/CPU0#r1(config)#int  gigabitEthernet 0/0/0/0RP/0/RP0/CPU0#r1(config-if)#no shutRP/0/RP0/CPU0#r1(config-if)#commitSun Sep  2 01#24#35.402 UTCRP/0/RP0/CPU0#r1(config-if)#Devbox#Received HeartBeatReceived HeartBeatEventType# SL_INTERFACE_EVENT_TYPE_INTERFACE_INFOInfo {  SLIfInfo {    Name# ~GigabitEthernet0/0/0/0~  }  IfState# SL_IF_STATE_UP  SeqNum# 12} Allocate Local labels and Create ILM entries# mpls_ilm.pyThis tutorial showcases how to register against the mpls vertical, allocate label blocks and then utilize these labels to create ILM (incoming label map) to forwarding function entries.Run mpls_ilm.py#admin@devbox#tutorial$ python3 mpls_ilm.pyUsing GRPC Server IP(10.10.20.170) Port(57021)Global thread spawnedServer Returned 0x502, Version 0.0.0Successfully Initialized, connection established!Max VRF Name Len     # 33Max Iface Name Len   # 64Max Paths per Entry  # 64Max Prim per Entry   # 32Max Bckup per Entry  # 32Max Labels per Entry # 3Min Prim Path-id     # 1Max Prim Path-id     # 64Min Bckup Path-id    # 65Max Bckup Path-id    # 128Max Remote Bckup Addr# 2MPLS SL_OBJOP_ADD Success!MPLS SL_OBJOP_UPDATE Success!admin@devbox#tutorial$Hop onto router r1 and dump the allocated label blocks#Username# adminPassword# adminSSH port# 2221Laptop-terminal$ ssh -p 2221 admin@10.10.20.170------------------------------------------------------------------------Router 1 (Cisco IOS XR Sandbox)------------------------------------------------------------------------Password#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#show  mpls label tableSun Sep  2 01#35#21.489 UTCTable Label   Owner                           State  Rewrite----- ------- ------------------------------- ------ -------0     0       LSD(A)                          InUse  Yes0     1       LSD(A)                          InUse  Yes0     2       LSD(A)                          InUse  Yes0     13      LSD(A)                          InUse  Yes0     30000   Static(A)#Service-layer         InUse  No0     31000   Static(A)#Service-layer         InUse  No0     32000   Static(A)#Service-layer         InUse  No0     33000   Static(A)#Service-layer         InUse  No0     34000   Static(A)#Service-layer         InUse  Yes0     35000   Static(A)#Service-layer         InUse  No0     36000   Static(A)#Service-layer         InUse  No0     37000   Static(A)#Service-layer         InUse  No0     38000   Static(A)#Service-layer         InUse  No0     39000   Static(A)#Service-layer         InUse  NoRP/0/RP0/CPU0#r1#Notice the labels marked Static(A)#Service-layer ? These were allocated by the mpls_ilm.py client.Now dump the mpls forwarding entries on the router#RP/0/RP0/CPU0#r1#show  mpls  forwardingSun Sep  2 01#38#58.400 UTCLocal  Outgoing    Prefix             Outgoing     Next Hop        Bytes       Label  Label       or ID              Interface                    Switched    ------ ----------- ------------------ ------------ --------------- ------------34000  10065       SR Pfx (idx 0)     Gi0/0/0/1    12.1.1.20       0           RP/0/RP0/CPU0#r1#Perfect! This showcases a SWAP entry created by the client. This entry will receive any packet with incoming-label=34000, swap it with label=10065 and forward it to the nexthop interface GigabitEthernet0/0/0/1 and nexthop address=12.1.1.20.Of course, you get to play with the usual mpls label operations like # PUSH, POP_AND_FORWARD, POP_AND_LOOKUP_IPV4 and POP_AND_LOOKUP_IPV6 to create ILM entries based on your use case.Now that we've seen the various service-layer API clients in action and their effects on the Router, let's break down the actual code in the `route.py` tutorial to learn how to write a client from scratch.",
      "url": "/wkinstructions/2019-02-01-step-6-quick-look-at-ios-xr-service-layer-api/",
      "author": "Akshat Sharma",
      "tags": "iosxr, cisco, service-layer, lab"
    }
    
    ,
  
  
  
    "wkinstructions-2019-01-30-step-7-combining-telemetry-with-ansible-and-open-r": {
      "title": "Step 7:  Combining Telemetry with Ansible and Open/R ",
      "content": "     On This Page  To Know More  Keep running the Telemetry client  Open/R Deployment          View the Open/R config files      Ansible Playbook to deploy Open/R      Run the Ansible Playbook        Establishing the BGP session          Check the Output of the Telemetry client        Conclusion  To Know MoreThere are several tools in the industry that allow you to play around with YANG models on IOS-XR and other Network OS stacks.In this workshop we will look at a few of them#      The Ansible netconf_config module to configure a BGP session on the routers. https#//docs.ansible.com/ansible/2.4/netconf_config_module.html    Yang Development Kit (YDK) to configure Telemetry and interfaces on the routers# http#//ydk.io  Your own python Telemetry client which we will use to extract python data coming from YANG paths set up by YDK#https#//learninglabs.cisco.com/tracks/iosxr-programmability/iosxr-streaming-telemetry/03-iosxr-02-telemetry-python/step/1. Also, a lot more on Telemetry here# https#//xrdocs.io/telemetry/  Connect to your Pod first! Make sure your Anyconnect VPN connection to the Pod assigned to you is active.  If you haven’t connected yet, check out the instructions to do so here#https#//sevt-sp.github.io/xr-programmability-lab/connect-to-pods/  Once you’re connected, use the following instructions to connect to the individual nodes.The instructions in the workshop will simply refer to the Name of the box to connect withoutrepeating the connection details and credentials. So refer back to this list when you need it.  The 3 nodes in the topology are#  Development Linux System (DevBox)   IP Address# 10.10.20.170 Username/Password# [admin/admin] SSH Port# 2211    IOS-XRv9000 R1# (Router r1)  IP Address# 10.10.20.170  Username/Password# [admin/admin]   Management IP# 10.10.20.170  XR SSH Port# 2221    NETCONF Port# 8321   gRPC Port# 57021  XR-Bash SSH Port# 2222        IOS-XRv9000 R2#  (Router r2)  IP Address# 10.10.20.170   Username/Password# [admin/admin]   Management IP# 10.10.20.170   XR SSH Port# 2231    NETCONF Port# 8331   gRPC Port# 57031    XR-Bash SSH Port# 2232  The Topology in use is shown below#Keep running the Telemetry clientBefore we begin Step 3 of this workshop where we combine IOS-XR Telemetry, Ansible, Open/R and Service-Layer APIs in XR, make sure you have run through Steps 1 and 2 already so that you have the Telemetry client already listening to BGP Session updates from router r1.To recap, at the end of Step 2, you must have one terminal window connected to your devbox where you have a client receiving data from router r1’s BGP Session (Currently in idle state). If not, please start it again as shown below.admin@devbox#python$ admin@devbox#python$ export SERVER_IP=10.10.20.170admin@devbox#python$ export SERVER_PORT=57021admin@devbox#python$ admin@devbox#python$ ./telemetry_client_json.py Using GRPC Server IP(10.10.20.170) Port(57021){   ~encoding_path~# ~Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/sessions/session~,    ~subscription_id_str~# ~1~,    ~collection_start_time~# 1548827148102,    ~msg_timestamp~# 1548827148108,    ~collection_end_time~# 1548827148108,    ~node_id_str~# ~r1~,    ~data_json~# [      {         ~keys~# {            ~neighbor-address~# ~60.1.1.1~,             ~instance-name~# ~default~         },          ~timestamp~# 1548827148107,          ~content~# {            ~messages-queued-in~# 0,             ~is-local-address-configured~# false,             ~local-as~# 65000,             ~nsr-state~# ~bgp-nbr-nsr-st-none~,             ~description~# ~~,             ~connection-remote-address~# {               ~ipv4-address~# ~60.1.1.1~,                ~afi~# ~ipv4~            },             ~messages-queued-out~# 0,             ~connection-state~# ~bgp-st-idle~,             ~speaker-id~# 0,             ~vrf-name~# ~default~,             ~remote-as~# 65000,             ~postit-pending~# false,             ~nsr-enabled~# true,             ~connection-local-address~# {               ~ipv4-address~# ~0.0.0.0~,                ~afi~# ~ipv4~            }         }      }   ],    ~collection_id~# 16}Open/R DeploymentWith the Telemetry client running, we can now progress to the next set of steps where we deploy Open/R as an application on both the routers.The basic deployment of Open/R we intend to achieve is represented below#View the Open/R config filesWe will use Ansible to deploy Open/R as docker instances to the routers r1 and r2. In addition to the docker instances, Open/R requires some configuration files to be present (much like an ISIS or BGP config). We will utilize Ansible to push these files to the routers as well.To view the relevant config files, open a new shell on the devbox with the telemetry client running in the earlier shell.Drop into the ansible/openr folder in the original xr-programmability-lab-code git repository you cloned earlier#admin@devbox#~$ cd xr-programmability-lab-code/admin@devbox#xr-programmability-lab-code$ lsansible  README.md  ydk  ztp_hooksadmin@devbox#xr-programmability-lab-code$ admin@devbox#xr-programmability-lab-code$ admin@devbox#xr-programmability-lab-code$ cd ansible/openr/admin@devbox#openr$ admin@devbox#openr$ lshosts_r1  increment_ipv4_prefix1.py  launch_openr_r1.sh  run_openr_r1.shhosts_r2  increment_ipv4_prefix2.py  launch_openr_r2.sh  run_openr_r2.shadmin@devbox#openr$       The hosts_rtr* files are used to set up /etc/hosts inside the docker container that we launch using Ansible. This setting is important for Open/R to work.        The launch_openr_*.sh scripts contain the actual docker run command which will launch the container and mount relevant config files into it.        The run_openr_*.sh script contains the configuration knobs for Open/R to know what routes to advertise to other Open/R instances on the network, the gRPC port for Service-Layer API to use while running locally on the router, the interfaces of XR that it should send its hellos out on, etc.        The increment_ipv4_prefix*.py script is an optional script we use to push a large set of routes into the configuration file for Open/R to advertise.  Ansible Playbook to deploy Open/RThe Ansible playbook we intend to use can be found in the ansible directory  of the xr-programmability-lab-code git repository#admin@devbox#~$ admin@devbox#~$ cd ~/xr-programmability-lab-code/admin@devbox#xr-programmability-lab-code$ cd ansible/admin@devbox#ansible$ admin@devbox#ansible$ cat docker_bringup.yml ---- hosts# routers_shell  gather_facts# no  sudo# yes  vars#    connect_vars#       host# ~~       username# ~~       password# ~~    up# ~sudo -i /misc/app_host/launch_openr_.sh~    down# ~sudo -i docker rm -f openr~  tasks#  - name# Copy run_openr script to rtr    copy#      src# ~~      dest# ~/misc/app_host/~      owner# root       group# root       mode# a+x   - name# Copy hosts_r file to rtr    copy#      src# ~~      dest# ~/misc/app_host/~      owner# root       group# root       mode# a+x   - name# Copy launch_openr script to rtr    copy#      src# ~~      dest# ~/misc/app_host/~      owner# root       group# root       mode# a+x   - name# Copy increment_ipv4 script to rtr    copy#      src# ~~      dest# ~/misc/app_host/~      owner# root       group# root       mode# a+x   - name# Copy cron file to rtr (CSCvh76067)    copy#      src# ~~      dest# ~/misc/app_host/ipv6_fe80_route_append.sh~      owner# root      group# root      mode# a+x  - name# Set up Cronjob (CSCvh76067)    cron#      name# set up ipv6 fe80##/64 routes       weekday# ~*~      minute# ~*~      hour# ~*~      user# root      job# ~/misc/app_host/ipv6_fe80_route_append.sh~      cron_file# ansible_ipv6_fe80_route_append  - name# Check docker container is running    shell# sudo -i docker inspect --format=' }}  openr    args#      executable# /bin/bash    register# status    ignore_errors# yes  - debug# var=output.stdout_lines   - name# Clean up docker container if running     shell# ~~    args#      executable# /bin/bash    register# output    when# status.stdout == ~true~  - debug# var=output.stdout_lines  - name# Bring up the docker container     shell# ~~    args#      executable# /bin/bash    register# output    ignore_errors# yes  - debug# var=output.stdout_lines  admin@devbox#ansible$ As can be seen above, the first 4 tasks of the playbook copy over the relevant config files and scripts for Open/R into /misc/app_host directory on the routers. This particular directory is mounted into the docker containers when we launch the container to make the config files available to Open/R inside the docker container.The 5th task is only required for this particular version of the IOS-XR software (6.4.1) we are using in the lab due to the bug# CSCvh76067 which prevents fe80##/64 routes from being installed for all interfaces in the kernel. This is fixed in subsequent releases of IOS-XR.We transport a cron job onto the router to fix this issue for this lab.The next 3 tasks are used to check if Open/R is already running, clean up if it is and then launch the docker container using the /misc/app_host/launch_openr.sh we transfered using task 3.Run the Ansible PlaybookRun the playbook as shown below#  IMPORTANT# Before you run the ansible playbook, make sure you set the &gt;ANSIBLE_HOST_KEY_CHECKING environment variable to false to allow Ansible to easily connect without being stalled by keychecking requirements for the two routers. This can also be set in the ansible_cfg file instead.  admin@devbox#ansible$ admin@devbox#ansible$ export ANSIBLE_HOST_KEY_CHECKING=False    {# .notice–danger} .admin@devbox#ansible$ ansible-playbook -i ansible_hosts docker_bringup.yml PLAY [routers_shell] ******************************************************************************************************************TASK [Copy run_openr script to rtr] ***************************************************************************************************ok# [r1]ok# [r2]TASK [Copy hosts_r file to rtr] *******************************************************************************************************ok# [r1]ok# [r2]TASK [Copy launch_openr script to rtr] ************************************************************************************************ok# [r2]ok# [r1]TASK [Copy increment_ipv4 script to rtr] **********************************************************************************************ok# [r1]ok# [r2]TASK [Copy cron file to rtr (CSCvh76067)] *********************************************************************************************ok# [r1]ok# [r2]TASK [Set up Cronjob (CSCvh76067)] ****************************************************************************************************ok# [r1]ok# [r2]TASK [Check docker container is running] ********************************************************************************************** [WARNING]# Consider using 'become', 'become_method', and 'become_user' rather than running sudochanged# [r1]changed# [r2]TASK [debug] **************************************************************************************************************************ok# [r2] =&gt; {    ~output.stdout_lines~# ~VARIABLE IS NOT DEFINED!~}ok# [r1] =&gt; {    ~output.stdout_lines~# ~VARIABLE IS NOT DEFINED!~}TASK [Clean up docker container if running] *******************************************************************************************changed# [r2]changed# [r1]TASK [debug] **************************************************************************************************************************ok# [r2] =&gt; {    ~output.stdout_lines~# [        ~openr~    ]}ok# [r1] =&gt; {    ~output.stdout_lines~# [        ~openr~    ]}TASK [Bring up the docker container] **************************************************************************************************changed# [r1]changed# [r2]TASK [debug] **************************************************************************************************************************ok# [r1] =&gt; {    ~output.stdout_lines~# [        ~4737c257d5fabf230b06aacd019bcc51e6af2e476befdf7774cd67766e5d1f06~    ]}ok# [r2] =&gt; {    ~output.stdout_lines~# [        ~10ea9e574a27b6132b139d233b52675ba3e8323fbc45c35c36faff71e3f55648~    ]}PLAY RECAP ****************************************************************************************************************************r1                         # ok=12   changed=3    unreachable=0    failed=0   r2                         # ok=12   changed=3    unreachable=0    failed=0   admin@devbox#ansible$ admin@devbox#ansible$ Perfect! Let’s check if the Open/R instances are now running on the routers properly#Log into router r1 and drop into “bash”#RP/0/RP0/CPU0#r1#bashWed Jan 30 12#41#59.867 UTC[r1#~]$ [r1#~]$ Issue a docker ps command to check that the container is running#[r1#~]$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESada4bf59c0b5        akshshar/openr-xr   ~/root/run_openr_r1.s~   17 minutes ago      Up 17 minutes                           openr[r1#~]$ Enter the docker container shell and exec into the global-vrf network namespace where open/R as a process is launched#[r1#~]$ [r1#~]$ docker exec -it openr bashroot@r1#/# root@r1#/# root@r1#/# ip netns exec global-vrf bashroot@r1#/# Issue the Open/R CLI commands (breeze commands) to check that the adjacency is properly established with router r2#root@r1#/# root@r1#/# breeze kvstore adj&gt; r1's adjacencies, version# 30, Node Label# 1, Overloaded?# FalseNeighbor    Local Interface    Remote Interface      Metric    Weight    Adj Label  NextHop-v4    NextHop-v6               Uptimer2          Gi0_0_0_0          Gi0_0_0_0                  7         1        50009  10.1.1.20     fe80##5054#ff#fe93#8ab0  15m53sr2          Gi0_0_0_1          Gi0_0_0_1                  7         1        50010  11.1.1.20     fe80##5054#ff#fe93#8ab1  15m53sr2          Gi0_0_0_2          Gi0_0_0_2                  6         1        50011  12.1.1.20     fe80##5054#ff#fe93#8ab2  15m53sroot@r1#/# root@r1#/# Check the number of routes learnt by Open/R in its FIB#root@r1#/# breeze fib counters== r1's Fib counters  ==fibagent.num_of_routes # 1004root@r1#/#Now exit back out from the container shell and from XR bash shell and issue a “show route” in the XR CLI of router r1#root@r1#/# root@r1#/# exitexitroot@r1#/# root@r1#/# exitexit[r1#~]$ [r1#~]$ [r1#~]$ exitlogoutRP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#show routeroute  router  RP/0/RP0/CPU0#r1#show routeWed Jan 30 12#47#08.968 UTCCodes# C - connected, S - static, R - RIP, B - BGP, (&gt;) - Diversion path       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP       i - ISIS, L1 - IS-IS level-1, L2 - IS-IS level-2       ia - IS-IS inter area, su - IS-IS summary null, * - candidate default       U - per-user static route, o - ODR, L - local, G  - DAGR, l - LISP       A - access/subscriber, a - Application route       M - mobile route, r - RPL, t - Traffic Engineering, (!) - FRR Backup pathGateway of last resort is 192.168.122.1 to network 0.0.0.0S*   0.0.0.0/0 [1/0] via 192.168.122.1, 01#15#05C    10.1.1.0/24 is directly connected, 01#07#20, GigabitEthernet0/0/0/0L    10.1.1.10/32 is directly connected, 01#07#20, GigabitEthernet0/0/0/0C    11.1.1.0/24 is directly connected, 01#07#20, GigabitEthernet0/0/0/1L    11.1.1.10/32 is directly connected, 01#07#20, GigabitEthernet0/0/0/1C    12.1.1.0/24 is directly connected, 01#07#20, GigabitEthernet0/0/0/2L    12.1.1.10/32 is directly connected, 01#07#20, GigabitEthernet0/0/0/2L    50.1.1.1/32 is directly connected, 01#07#20, Loopback0a    60.1.1.1/32 [99/0] via 11.1.1.20, 00#00#04, GigabitEthernet0/0/0/1a    120.1.1.0/24 [99/0] via 11.1.1.20, 00#00#03, GigabitEthernet0/0/0/1a    120.1.2.0/24 [99/0] via 11.1.1.20, 00#00#03, GigabitEthernet0/0/0/1a    120.1.3.0/24 [99/0] via 11.1.1.20, 00#00#03, GigabitEthernet0/0/0/1a    120.1.4.0/24 [99/0] via 11.1.1.20, 00#00#04, GigabitEthernet0/0/0/1a    120.1.5.0/24 [99/0] via 11.1.1.20, 00#00#03, GigabitEthernet0/0/0/1a    120.1.6.0/24 [99/0] via 11.1.1.20, 00#00#03, GigabitEthernet0/0/0/1a    120.1.7.0/24 [99/0] via 11.1.1.20, 00#00#04, GigabitEthernet0/0/0/1a    120.1.8.0/24 [99/0] via 11.1.1.20, 00#00#03, GigabitEthernet0/0/0/1a    120.1.9.0/24 [99/0] via 11.1.1.20, 00#00#04, GigabitEthernet0/0/0/1a    120.1.10.0/24 [99/0] via 11.1.1.20, 00#00#04, GigabitEthernet0/0/0/1a    120.1.11.0/24 [99/0] via 11.1.1.20, 00#00#03, GigabitEthernet0/0/0/1a    120.1.12.0/24 [99/0] via 11.1.1.20, 00#00#03, GigabitEthernet0/0/0/1a    120.1.13.0/24 [99/0] via 11.1.1.20, 00#00#04, GigabitEthernet0/0/0/1a    120.1.14.0/24 [99/0] via 11.1.1.20, 00#00#04, GigabitEthernet0/0/0/1 --More-- Awesome! Routes are learnt by Open/R from its neighbor running on r2 and these routes are programmed into Router r1’s RIB using the Service-Layer API. These routes show up as application routes (a routes in the show route output above).Establishing the BGP sessionNow that Open/R has learnt the routes from router r2, particularly the loopback0 route (60.1.1.1) from r2, the BGP session between the two routers should now be established#RP/0/RP0/CPU0#r1#show  bgp sessions Wed Jan 30 12#49#57.225 UTCNeighbor        VRF                   Spk    AS   InQ  OutQ  NBRState     NSRState60.1.1.1        default                 0 65000     0     0  Established  NoneRP/0/RP0/CPU0#r1#RP/0/RP0/CPU0#r1#Check the Output of the Telemetry clientWith the BGP session established, you should now see the following change in the output of the telemetry client we were running initially{   ~encoding_path~# ~Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/sessions/session~,    ~subscription_id_str~# ~1~,    ~collection_start_time~# 1548852684404,    ~msg_timestamp~# 1548852684408,    ~collection_end_time~# 1548852684408,    ~node_id_str~# ~r1~,    ~data_json~# [      {         ~keys~# {            ~neighbor-address~# ~60.1.1.1~,             ~instance-name~# ~default~         },          ~timestamp~# 1548852684407,          ~content~# {            ~messages-queued-in~# 0,             ~is-local-address-configured~# false,             ~local-as~# 65000,             ~nsr-state~# ~bgp-nbr-nsr-st-none~,             ~description~# ~~,             ~connection-remote-address~# {               ~ipv4-address~# ~60.1.1.1~,                ~afi~# ~ipv4~            },             ~messages-queued-out~# 0,             ~connection-state~# ~bgp-st-estab~,             ~speaker-id~# 0,             ~vrf-name~# ~default~,             ~remote-as~# 65000,             ~postit-pending~# false,             ~nsr-enabled~# true,             ~connection-local-address~# {               ~ipv4-address~# ~50.1.1.1~,                ~afi~# ~ipv4~            }         }      }   ],    ~collection_id~# 33}The ~connection-state~# ~bgp-st-estab~ in the output above has changed from ~connection-state~# ~bgp-st-idle~. Open/R acts as an IGP, learning the loopback routes used by BGP to establish the required session!ConclusionTo wrap up, this is what we achieved as part of this lab#  Used ZTP CLI hooks in bash to configure grpc, interfaces and loopbacks on each router  Scaled up the setup by switching to ansible to execute the python ZTP CLI script to configure a new user and configure routes required to allow the docker daemon to download an Open/R image subsequently  Used Ansible to with netconf_config module to send XML encoded BGP YANG model snippet to configure I-BGP on both the routers over netconf.  Used YDK to configure Telemetry on Router r1 using the OpenConfig Telemetry Yang Model.  Started a simple Telemetry python client that is able to dial-in and receive telemetry data about the BGP session in 15 second intervals  Used Ansible to setup and launch the Open/R docker containers on each router  Utilized the Service-Layer API intergration of Open/R to program routes into the IOS-XR RIB and act as an IGP  With the help of the routes learned by Open/R, the BGP session was able to come up and get established and the same was reflected in the telemetry data received by the telemetry client.",
      "url": "/wkinstructions/2019-01-30-step-7-combining-telemetry-with-Ansible-and-Open-r/",
      "author": "Akshat Sharma",
      "tags": "iosxr, cisco, CLUS2018, devnet, programmability"
    }
    
    
  
,
  "#": {}
}
